<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ðŸ“¦ csl::ag: Documentation : csl::wf</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="github_emoji_unicode_1f4e6.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ðŸ“¦ csl::ag
   </div>
   <div id="projectbrief">Tuple-like interface (get/element/size) - thus, structured-binding - for aggregates type.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md__home_runner_work_CppShelf_CppShelf_docs_details_markdown_wf.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Documentation : csl::wf </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The goal of <code>csl::wf</code> is to offer convenient ways to manipulate functors &amp; callable values in general.</p>
<p>This library is divided in three parts :</p>
<ul>
<li>Invocation <a href="#invocation-utilities"><b>functions</b></a> *(<code>invoke</code>, <code>apply</code>, etc.)*, <br  />
 and <a href="#invocation-traits"><b>type-traits</b></a> *(<code>is_invocable</code>, <code>is_applyable</code>, <code>is_nothrow_invocable_r</code>, etc.)*</li>
<li>Functors <b>types</b> with specific purpose *(front_binder, overload, repeater, etc.)*</li>
<li>An <a href="#edsl"><b>eDSL</b></a> to create complexe workflow easily</li>
</ul>
<hr  />
<ul>
<li><a href="#documentation--cslwf">Documentation : csl::wf</a><ul>
<li><a href="#philosophy--design-choices">Philosophy &amp; design choices</a></li>
<li><a href="#invocation-utilities">Invocation utilities</a><ul>
<li><a href="#invoke"><b>invoke</b></a></li>
<li><a href="#apply"><b>apply</b></a></li>
<li><a href="#apply_before">apply_before</a></li>
<li><a href="#apply_after">apply_after</a></li>
</ul>
</li>
<li><a href="#invocation-traits">Invocation traits</a><ul>
<li><a href="#is_invocable">is_invocable</a></li>
<li><a href="#is_nothrow_invocable">is_nothrow_invocable</a></li>
<li><a href="#is_invocable_r">is_invocable_r</a></li>
<li><a href="#is_nothrow_invocable_r">is_nothrow_invocable_r</a></li>
<li><a href="#invoke_result">invoke_result</a></li>
<li><a href="#is_applyable">is_applyable</a></li>
<li><a href="#is_nothrow_applyable">is_nothrow_applyable</a></li>
<li><a href="#is_applyable_before">is_applyable_before</a></li>
<li><a href="#is_nothrow_applyable_before">is_nothrow_applyable_before</a></li>
<li><a href="#is_applyable_after">is_applyable_after</a></li>
<li><a href="#is_nothrow_applyable_after">is_nothrow_applyable_after</a></li>
<li><a href="#apply_result">apply_result</a></li>
<li><a href="#is_invocable_with">is_invocable_with</a></li>
<li><a href="#is_nothrow_invocable_with">is_nothrow_invocable_with</a></li>
</ul>
</li>
<li><a href="#bind_front">bind_front</a><ul>
<li><a href="#front_bindable-concept">front_bindable (concept)</a></li>
<li><a href="#front_binder-type">front_binder (type)</a></li>
</ul>
</li>
<li><a href="#invocation-policies">invocation policies</a><ul>
<li><a href="#cslwfinvoke_policyallow_discard">csl::wf::invoke_policy::allow_discard</a></li>
<li><a href="#cslwfinvoke_policynodiscard">csl::wf::invoke_policy::nodiscard</a></li>
</ul>
</li>
<li><a href="#chain">chain</a><ul>
<li><a href="#mpchain_traittypename--fs"><code>mp::chain_trait&lt;typename ... Fs&gt;</code></a></li>
<li><a href="#chain_invoke">chain_invoke</a></li>
<li><a href="#chain_invoke_nodiscard">chain_invoke_nodiscard</a></li>
<li><a href="#chain_invocable-concept">chain_invocable (concept)</a></li>
<li><a href="#route-type">route (type)</a><ul>
<li><a href="#getindexinstance_ofroute">get&lt;index&gt;(instance_of&lt;route&gt;)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#overload">overload</a></li>
<li><a href="#repeater">repeater</a></li>
<li><a href="#function_reft">function_ref&lt;T&gt;</a></li>
<li><a href="#function_viewt">function_view&lt;T&gt;</a></li>
<li><a href="#edsl">eDSL</a><ul>
<li><a href="#_times-literals">_times (literals)</a></li>
<li><a href="#factories">factories</a><ul>
<li><a href="#make_continuation">make_continuation</a></li>
<li><a href="#make_condition">make_condition</a></li>
<li><a href="#make_repetition">make_repetition</a></li>
</ul>
</li>
<li><a href="#operators">operators</a><ul>
<li><a href="#operator-pipe-operator"><code>operator|</code> (pipe operator)</a><ul>
<li><a href="#f1--f2">F1 | F2</a></li>
<li><a href="#f--ref">F | ref</a></li>
<li><a href="#f--cref">F | cref</a></li>
<li><a href="#f--view">F | view</a></li>
</ul>
</li>
<li><a href="#operator-right-shift-assign-operator"><code>operator&gt;&gt;=</code> (right-shift-assign operator)</a></li>
<li><a href="#operator-star-operator"><code>operator*</code> (star operator)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md37"></a>
Philosophy &amp; design choices</h1>
<p>The key idea of this library is to provide a convenient way to deal with functors which <code>operator()</code> are conditionaly-generated, have multiple overloads, or simply have template-parameters.</p>
<blockquote class="doxtable">
<p>As-is, only template-type parameters are supported. </p>
</blockquote>
<p>Such design is in opposition to STL's <code>&lt;functional&gt;</code>, where types like <code>std::function</code> provides a type-erasure restrained by a unique function signature.</p>
<p>To allow multiples templates-parameters-pack in signatures, and represent for instance in one hand template-type-parameters and generic-parameters on the other, <br  />
 a type named <code>ttps&lt;...&gt;</code> is used to ease deduction. <br  />
 For some specific corner-cases, a type named <code>arg&lt;...&gt;</code> is also used to wrap <code>parameters</code>'s types in the same way.</p>
<p>It also provides a precise support to <code>operator()</code> cvref-qualifiers.</p>
<h1><a class="anchor" id="autotoc_md38"></a>
Invocation utilities</h1>
<blockquote class="doxtable">
<p>Similar to the STL equivalents, <br  />
 but offer two ways to pass template-type-parameters to the callable value. </p>
</blockquote>
<ul>
<li><p class="startli">As template-type-parameters to the function itself</p>
<p class="startli">```cpp csl::wf::invoke&lt;std::string&gt;(func, 42); // ^^^^^^^^^^^^^ ```</p>
</li>
<li><p class="startli">As an optional <code>csl::wf::ttps&lt;...&gt;</code> regular parameter</p>
<p class="startli">```cpp csl::wf::invoke(func, ttps&lt;std::string&gt;{}, 42); // ^^^^^^^^^^^^^^^^^^^ ```</p>
</li>
</ul>
<p>The correct invocation synthax is then deduced.</p>
<p>Note that all implementations are conditionaly enabled/disabled using proper concepts. <br  />
 Thus, invalid synthax will result in an invalid overload-resolution.</p>
<h2><a class="anchor" id="autotoc_md39"></a>
&lt;strong&gt;invoke&lt;/strong&gt;</h2>
<p>Signatures :</p>
<div class="fragment"><div class="line"><span class="comment">// (1) - similar to std::invoke</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> ... args_types&gt;</div>
<div class="line">constexpr decltype(<span class="keyword">auto</span>) invoke(F &amp;&amp; f, args_types&amp;&amp; ... args) noexcept();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// (2) - with template-type-parameter-pack</span></div>
<div class="line">template &lt;typename ... ttps_args, typename F, typename ... args_types&gt;</div>
<div class="line">constexpr decltype(auto) invoke(F &amp;&amp; f, args_types&amp;&amp; ... args) noexcept();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// (3) - with template-type-parameter-pack as a function parameter of type csl::wf::mp::ttps&lt;...&gt;</span></div>
<div class="line">template &lt;typename ... ttps_args, typename F, typename ... args_types&gt;</div>
<div class="line">constexpr decltype(auto) invoke(F &amp;&amp; f, mp::ttps&lt;ttps_args...&gt;, args_types&amp;&amp; ... args) noexcept();</div>
</div><!-- fragment --><p>Examples :</p>
<div class="fragment"><div class="line">constexpr <span class="keyword">auto</span> func = []&lt;<span class="keyword">typename</span> T&gt;(<span class="keyword">auto</span> &amp;&amp; value){};</div>
<div class="line">func.template operator()&lt;std::string&gt;(42);  <span class="comment">// regular function invocation</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// std::invoke</span></div>
<div class="line">std::invoke(&amp;std::remove_cvref_t&lt;decltype(func)&gt;::<span class="keyword">template</span> <span class="keyword">operator</span>()&lt;std::string, <span class="keywordtype">int</span>&gt;, func, 42);</div>
<div class="line"><span class="comment">//                                    notice the 2nd template-type-parameter here  ^^^</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// csl::wf::invoke</span></div>
<div class="line">csl::wf::invoke&lt;std::string&gt;(func, 42);         <span class="comment">// (2) : template-type-parameters as invoke template-type-parameters</span></div>
<div class="line">csl::wf::invoke(func, ttps&lt;std::string&gt;{}, 42); <span class="comment">// (3) : or as 2nd optional parameters</span></div>
</div><!-- fragment --><p>Try it on <a href="https://godbolt.org/z/MbeqxEnG4">Godbolt here</a></p>
<h2><a class="anchor" id="autotoc_md40"></a>
&lt;strong&gt;apply&lt;/strong&gt;</h2>
<blockquote class="doxtable">
<p>Similar to <code>std::apply</code>, <br  />
 but provides two ways to pass template-type-parameters, in a similar fashion to <code>csl::wf::invoke</code>. </p>
</blockquote>
<p>Signatures :</p>
<div class="fragment"><div class="line"><span class="comment">// (1) - with template-type-parameter-pack</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ... f_ts, <span class="keyword">typename</span> F, concepts::tupleinterface_not_starting_with_ttps args_as_tuple_t&gt;</div>
<div class="line">constexpr decltype(<span class="keyword">auto</span>) apply(F &amp;&amp; f, args_as_tuple_t&amp;&amp; args) noexcept();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// (2) - with template-type-parameter-pack as first TupleType element</span></div>
<div class="line">template &lt;typename F, concepts::tupleinterface_starting_with_ttps args_as_tuple_t&gt;</div>
<div class="line">constexpr decltype(auto) apply(F &amp;&amp; f, args_as_tuple_t &amp;&amp; args) noexcept();</div>
</div><!-- fragment --><p>Examples :</p>
<div class="fragment"><div class="line">constexpr <span class="keyword">auto</span> func = []&lt;<span class="keyword">typename</span> T&gt;(<span class="keyword">auto</span> &amp;&amp; arg0, <span class="keyword">auto</span> &amp;&amp; arg1){};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// std::apply</span></div>
<div class="line"><span class="keyword">using namespace </span>std::placeholders;</div>
<div class="line">std::apply(</div>
<div class="line">    std::bind(</div>
<div class="line">        &amp;std::remove_cvref_t&lt;decltype(func)&gt;::<span class="keyword">template</span> <span class="keyword">operator</span>()&lt;std::string, <span class="keywordtype">char</span>, <span class="keywordtype">int</span>&gt;,</div>
<div class="line">        func,</div>
<div class="line">        _1, _2</div>
<div class="line">    ), </div>
<div class="line">    std::tuple{<span class="charliteral">&#39;A&#39;</span>, 42}</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// csl::wf::apply</span></div>
<div class="line">csl::wf::apply&lt;std::string&gt;(func, std::tuple{<span class="charliteral">&#39;A&#39;</span>, 42});             <span class="comment">// (1)</span></div>
<div class="line">csl::wf::apply(func, std::tuple{ ttps&lt;std::string&gt;{}, <span class="charliteral">&#39;A&#39;</span>, 42 });   <span class="comment">// (2)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md41"></a>
apply_before</h2>
<p>Apply the values contained in the tuple <b>before</b> optional additional values.</p>
<p>Signature :</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ... f_ts, <span class="keyword">typename</span> F, concepts::tuple_interface args_as_tuple_t, <span class="keyword">typename</span> ... func_args_t&gt;</div>
<div class="line">constexpr decltype(<span class="keyword">auto</span>) apply_before(F &amp;&amp; f, args_as_tuple_t&amp;&amp; args, func_args_t&amp;&amp; ... func_args) noexcept()</div>
</div><!-- fragment --><p>Examples :</p>
<div class="fragment"><div class="line">constexpr <span class="keyword">auto</span> func = []&lt;<span class="keyword">typename</span> T&gt;(<span class="keyword">auto</span> &amp;&amp; arg0, <span class="keyword">auto</span> &amp;&amp; arg1){};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// csl::wf::apply_before</span></div>
<div class="line">csl::wf::apply_before&lt;std::string&gt;(func, std::tuple{ A{}, B{} });</div>
<div class="line">csl::wf::apply_before&lt;std::string&gt;(func, std::tuple{ A{} }, B{});</div>
<div class="line">csl::wf::apply_before&lt;std::string&gt;(func, std::tuple{}, A{}, B{});</div>
<div class="line"> </div>
<div class="line">csl::wf::apply_before(func, std::tuple{ ttps&lt;std::string&gt;{}, A{}, B{} });</div>
<div class="line">csl::wf::apply_before(func, std::tuple{ ttps&lt;std::string&gt;{}, A{}},  B{});</div>
<div class="line">csl::wf::apply_before(func, std::tuple{ ttps&lt;std::string&gt;{} }, A{}, B{} );</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md42"></a>
apply_after</h2>
<p>Apply the values contained in the tuple <b>after</b> optional additional values.</p>
<p>Signature :</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ... f_ts, <span class="keyword">typename</span> F, concepts::tuple_interface args_as_tuple_t, <span class="keyword">typename</span> ... func_args_t&gt;</div>
<div class="line">constexpr decltype(<span class="keyword">auto</span>) apply_after(F &amp;&amp; f, args_as_tuple_t&amp;&amp; args, func_args_t&amp;&amp; ... func_args) noexcept()</div>
</div><!-- fragment --><div class="fragment"><div class="line">constexpr <span class="keyword">auto</span> func = []&lt;<span class="keyword">typename</span> T&gt;(<span class="keyword">auto</span> &amp;&amp; arg0, <span class="keyword">auto</span> &amp;&amp; arg1){};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// csl::wf::apply_after</span></div>
<div class="line">csl::wf::apply_after&lt;std::string&gt;(func, std::tuple{ A{}, B{} });</div>
<div class="line">csl::wf::apply_after&lt;std::string&gt;(func, std::tuple{ B{} }, A{});</div>
<div class="line">csl::wf::apply_after&lt;std::string&gt;(func, std::tuple{}, A{}, B{});</div>
<div class="line"> </div>
<div class="line">csl::wf::apply_after(func, std::tuple{ ttps&lt;std::string&gt;{}, A{}, B{} });</div>
<div class="line">csl::wf::apply_after(func, std::tuple{ A{}, B{} }, ttps&lt;std::string&gt;{});</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md43"></a>
Invocation traits</h1>
<p>Available either as type-traits, or constexpr template-variable with <code>_v</code> prefix.</p>
<h2><a class="anchor" id="autotoc_md44"></a>
is_invocable</h2>
<div class="fragment"><div class="line">is_invocable&lt;F, [ttps&lt;...&gt;,] args_types...&gt;</div>
</div><!-- fragment --><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">parameter </th><th class="markdownTableHeadNone">description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>F</code> </td><td class="markdownTableBodyNone">A type, most likely a functor  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>ttps&lt;...&gt;</code> </td><td class="markdownTableBodyNone">template-type-parameters  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>args_types</code> </td><td class="markdownTableBodyNone">Parameters types.<br  />
Must be complete types usable in an unevaluated context.  </td></tr>
</table>
<hr  />
<p>Similar to <a href="https://en.cppreference.com/w/cpp/types/is_invocable">std::is_invocable</a>, but <code>F</code> can be a functor with multiples <code>operator()</code> overload, and supports template-type-parameters. An additional non-mandatory (possibly cv-ref-qualified) <code>ttps&lt;...&gt;</code> parameter can be used to pass template-type-parameters.</p>
<p>Determines whether</p><ul>
<li><code>F</code> can be invoked with non-mandatory template-type-parameter <code>ttps&lt;...&gt;</code></li>
<li>and arguments <code>args_types...</code></li>
</ul>
<blockquote class="doxtable">
<p>Note : <code>ttps&lt;...&gt;</code> can be <b>cvref-qualified</b>. If so, the behavior remain the same. </p>
</blockquote>
<div class="fragment"><div class="line"><span class="keyword">auto</span> func = [](){};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> F = decltype(func);</div>
<div class="line"><span class="keyword">using namespace </span>csl::wf;</div>
<div class="line"> </div>
<div class="line">static_assert(mp::is_invocable_v&lt;F&gt;);                   <span class="comment">// evaluate func()</span></div>
<div class="line">static_assert(mp::is_invocable_v&lt;F, <a class="code" href="structcsl_1_1wf_1_1mp_1_1ttps.html">ttps&lt;&gt;</a>&gt;);           <span class="comment">// evaluate func()</span></div>
<div class="line">static_assert(mp::is_invocable_v&lt;F, <span class="keyword">const</span> <a class="code" href="structcsl_1_1wf_1_1mp_1_1ttps.html">ttps&lt;&gt;</a> &amp;&amp;&gt;);  <span class="comment">// evaluate func()</span></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">auto</span> func = []&lt;<span class="keyword">typename</span> ... Ts&gt;(<span class="keyword">auto</span> &amp;&amp; ... args){};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> F = decltype(func);</div>
<div class="line"><span class="keyword">using namespace </span>csl::wf;</div>
<div class="line"> </div>
<div class="line">static_assert(mp::is_invocable_v&lt;F, int&gt;);              <span class="comment">// evaluate func(int{})</span></div>
<div class="line">static_assert(mp::is_invocable_v&lt;F, int, char&gt;);        <span class="comment">// evaluate func(int{}, char{})</span></div>
<div class="line"> </div>
<div class="line">static_assert(mp::is_invocable_v&lt;F, <a class="code" href="structcsl_1_1wf_1_1mp_1_1ttps.html">ttps&lt;&gt;</a>&gt;);           <span class="comment">// evaluate func&lt;&gt;()</span></div>
<div class="line">static_assert(mp::is_invocable_v&lt;F, <a class="code" href="structcsl_1_1wf_1_1mp_1_1ttps.html">ttps&lt;&gt;</a>, <span class="keywordtype">int</span>&gt;);      <span class="comment">// evaluate func&lt;&gt;(int{})</span></div>
<div class="line">static_assert(mp::is_invocable_v&lt;F, <a class="code" href="structcsl_1_1wf_1_1mp_1_1ttps.html">ttps&lt;char&gt;</a>, <span class="keywordtype">int</span>&gt;);  <span class="comment">// evaluate func&lt;char&gt;(int{})</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md46"></a>
is_nothrow_invocable</h2>
<div class="fragment"><div class="line">is_nothrow_invocable&lt;F, [ttps&lt;...&gt;,] args_types...&gt;</div>
</div><!-- fragment --><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">parameter </th><th class="markdownTableHeadNone">description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>F</code> </td><td class="markdownTableBodyNone">A type, most likely a functor  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>ttps&lt;...&gt;</code> </td><td class="markdownTableBodyNone">template-type-parameters  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>args_types</code> </td><td class="markdownTableBodyNone">Parameters types.<br  />
Must be complete types usable in an unevaluated context.  </td></tr>
</table>
<hr  />
<p>Similar to <a href="https://en.cppreference.com/w/cpp/types/is_invocable">std::is_nothrow_invocable</a>, but in a fashion similar to <code><a class="el" href="structcsl_1_1wf_1_1mp_1_1is__invocable.html">csl::wf::mp::is_invocable</a></code>.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>F {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...&gt;</div>
<div class="line">    <span class="keywordtype">void</span> operator()() const &amp; {}</div>
<div class="line">    <span class="keywordtype">void</span> operator()() &amp; noexcept {}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>csl::wf;</div>
<div class="line"> </div>
<div class="line">static_assert(not <a class="code" href="structcsl_1_1wf_1_1mp_1_1is__invocable.html">mp::is_invocable&lt;F&amp;, int&gt;</a>);</div>
<div class="line">static_assert(not <a class="code" href="structcsl_1_1wf_1_1mp_1_1is__nothrow__invocable.html">mp::is_nothrow_invocable&lt;F&amp;, int&gt;</a>);</div>
<div class="line"> </div>
<div class="line">static_assert(<a class="code" href="structcsl_1_1wf_1_1mp_1_1is__invocable.html">mp::is_invocable&lt;const F&amp;&gt;</a>);</div>
<div class="line">static_assert(<a class="code" href="structcsl_1_1wf_1_1mp_1_1is__invocable.html">mp::is_invocable</a>&lt;<span class="keyword">const</span> F&amp;, <a class="code" href="structcsl_1_1wf_1_1mp_1_1ttps.html">ttps&lt;&gt;</a>&gt;);</div>
<div class="line">static_assert(not <a class="code" href="structcsl_1_1wf_1_1mp_1_1is__nothrow__invocable.html">mp::is_nothrow_invocable&lt;const F&amp;&gt;</a>);</div>
<div class="line"> </div>
<div class="line">static_assert(<a class="code" href="structcsl_1_1wf_1_1mp_1_1is__invocable.html">mp::is_invocable&lt;F&amp;&gt;</a>);</div>
<div class="line">static_assert(<a class="code" href="structcsl_1_1wf_1_1mp_1_1is__invocable.html">mp::is_invocable</a>&lt;F&amp;, <a class="code" href="structcsl_1_1wf_1_1mp_1_1ttps.html">ttps&lt;&gt;</a>&gt;);</div>
<div class="line">static_assert(<a class="code" href="structcsl_1_1wf_1_1mp_1_1is__nothrow__invocable.html">mp::is_nothrow_invocable&lt;F&amp;&gt;</a>);</div>
<div class="line">static_assert(<a class="code" href="structcsl_1_1wf_1_1mp_1_1is__nothrow__invocable.html">mp::is_nothrow_invocable</a>&lt;F&amp;, <a class="code" href="structcsl_1_1wf_1_1mp_1_1ttps.html">ttps&lt;&gt;</a>&gt;);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md48"></a>
is_invocable_r</h2>
<div class="fragment"><div class="line">is_invocable_r&lt;R, F, [ttps&lt;...&gt;,] args_types...&gt;</div>
</div><!-- fragment --><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">parameter </th><th class="markdownTableHeadNone">description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>R</code> </td><td class="markdownTableBodyNone">Type that the invocation result's value must be convertible to  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>F</code> </td><td class="markdownTableBodyNone">A type, most likely a functor  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>ttps&lt;...&gt;</code> </td><td class="markdownTableBodyNone">template-type-parameters  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>args_types</code> </td><td class="markdownTableBodyNone">Parameters types.<br  />
Must be complete types usable in an unevaluated context.  </td></tr>
</table>
<hr  />
<p>Similar to <a href="[std::is_invocable_r](https://en.cppreference.com/w/cpp/types/is_invocable)">std::is_invocable_r</a>, but with an additional non-mandatory (possibly cv-ref-qualified) <code>ttps&lt;...&gt;</code> parameter to pass template-type-parameters. Determines whether</p><ul>
<li><code>F</code> can be invoked with non-mandatory template-type-parameter <code>ttps&lt;...&gt;</code></li>
<li>and arguments <code>args_types...</code>, to yield a result that is convertible to <code>R</code></li>
</ul>
<p>In a nutshell,</p><ul>
<li>if <code>ttps&lt;...&gt;</code> is missing, or its template-type-parameters sequence is empty, <br  />
 then the behavior is strictly identical to a regular call to <code>std::is_invocable_r</code>. <br  />
</li>
<li>if <code>ttps&lt;...&gt;</code> template-type-parameters <b>is not</b> empty, <br  />
 then this will check if the type of the following expression is convertible to <code>R</code> :</li>
</ul>
<div class="fragment"><div class="line">std::declval&lt;F&gt;().template operator()&lt;ttps_args...&gt;(std::declval&lt;args_types&gt;()...)</div>
</div><!-- fragment --><hr  />
<p>Like its STL counterpart, if <code>R</code> is <code>void</code>, then the result can be any type. <br  />
</p>
<p>```cpp auto func = []&lt;typename ... Ts&gt;(auto &amp;&amp; value){ return std::common_type_t&lt;decltype(value), Ts...&gt;(); } using F = decltype(func);</p>
<p>static_assert(csl::wf::mp::is_invocable_r_v&lt; int, // return type must be convertible to <code>int</code> F, // functor type ttps&lt;char, int&gt;, // ttps bool // args &gt;);</p>
<p>static_assert(csl::wf::mp::is_invocable_r_v&lt; int, // return type must be convertible to <code>int</code> F, // functor type // no ttps bool // args &gt;);</p>
<div class="fragment"><div class="line">### is_nothrow_invocable_r</div>
<div class="line"> </div>
<div class="line">```cpp</div>
<div class="line">is_nothrow_invocable_r&lt;F, [ttps&lt;...&gt;,] args_types...&gt;</div>
</div><!-- fragment --><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">parameter </th><th class="markdownTableHeadNone">description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>R</code> </td><td class="markdownTableBodyNone">Type that the invocation result's value must be convertible to  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>F</code> </td><td class="markdownTableBodyNone">A type, most likely a functor  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>ttps&lt;...&gt;</code> </td><td class="markdownTableBodyNone">template-type-parameters  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>args_types</code> </td><td class="markdownTableBodyNone">Parameters types.<br  />
Must be complete types usable in an unevaluated context.  </td></tr>
</table>
<hr  />
<p>Same as <a href="#is_invocable_r">is_invocable_r</a>, but with an additional non-mandatory (possibly cv-ref-qualified) <code>ttps&lt;...&gt;</code> parameter to pass template-type-parameters. Determines whether</p><ul>
<li><code>F</code> can be invoked with non-mandatory template-type-parameter <code>ttps&lt;...&gt;</code></li>
<li>and arguments <code>args_types...</code>, to yield a result that is convertible to <code>R</code></li>
<li>and that call is known <b>not</b> to throw any exception (<code>noexcept</code>).</li>
</ul>
<p>Like its STL counterpart, if <code>R</code> is <code>void</code>, then the result can be any type. <br  />
 The conversion of the parameters and the call itself still has to be known <b>not</b> to throw any exceptions.</p>
<p>In a nutshell,</p><ul>
<li>if <code>ttps&lt;...&gt;</code> is missing, or its template-type-parameters sequence is empty, <br  />
 then the behavior is strictly identical to a regular call to <code>std::is_invocable_r</code>. <br  />
</li>
<li>if <code>ttps&lt;...&gt;</code> template-type-parameters <b>is not</b> empty, <br  />
 then this will check if the type of the following expression is convertible to <code>R</code> :</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">struct </span>A{}; <span class="keyword">struct </span>B{}; <span class="keyword">struct </span>C{};</div>
<div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">  <span class="keyword">auto</span> operator()()    const          -&gt; A { <span class="keywordflow">return</span> {} };</div>
<div class="line">  <span class="keyword">auto</span> operator()(<span class="keywordtype">int</span>) <span class="keyword">const</span> noexcept -&gt; B { <span class="keywordflow">return</span> {} };</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">  <span class="keyword">auto</span> operator()() const noexcept(std::same_as&lt;T, C&gt;) -&gt; C { <span class="keywordflow">return</span> {} };</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// invocation is not noexcept</span></div>
<div class="line">static_assert(not <a class="code" href="structcsl_1_1wf_1_1mp_1_1is__nothrow__invocable__r.html">csl::wf::mp::is_nothrow_invocable_r</a>&lt;</div>
<div class="line">  A,</div>
<div class="line">  <span class="keyword">const</span> functor</div>
<div class="line">&gt;);</div>
<div class="line">static_assert(not <a class="code" href="structcsl_1_1wf_1_1mp_1_1is__nothrow__invocable__r.html">csl::wf::mp::is_nothrow_invocable_r</a>&lt;</div>
<div class="line">  A,</div>
<div class="line">  <span class="keyword">const</span> functor,</div>
<div class="line">  ttps&lt;&gt;  <span class="comment">// can be cvref-qualified</span></div>
<div class="line">&gt;);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// invocation&#39;s result type is not convertible to `A` (returns B)</span></div>
<div class="line">static_assert(not <a class="code" href="structcsl_1_1wf_1_1mp_1_1is__nothrow__invocable__r.html">csl::wf::mp::is_nothrow_invocable_r</a>&lt;</div>
<div class="line">  A,</div>
<div class="line">  <span class="keyword">const</span> functor,</div>
<div class="line">  <span class="keywordtype">int</span>,</div>
<div class="line">&gt;);</div>
<div class="line"><span class="comment">// ok</span></div>
<div class="line">static_assert(<a class="code" href="structcsl_1_1wf_1_1mp_1_1is__nothrow__invocable__r.html">csl::wf::mp::is_nothrow_invocable_r</a>&lt;</div>
<div class="line">  B,</div>
<div class="line">  <span class="keyword">const</span> functor,</div>
<div class="line">  <span class="keywordtype">int</span>,</div>
<div class="line">&gt;);</div>
<div class="line"><span class="comment">// same as before</span></div>
<div class="line">static_assert(<a class="code" href="structcsl_1_1wf_1_1mp_1_1is__nothrow__invocable__r.html">csl::wf::mp::is_nothrow_invocable_r</a>&lt;</div>
<div class="line">  B,</div>
<div class="line">  <span class="keyword">const</span> functor,</div>
<div class="line">  ttps&lt;&gt;</div>
<div class="line">  <span class="keywordtype">int</span>,</div>
<div class="line">&gt;);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ok</span></div>
<div class="line">static_assert(<a class="code" href="structcsl_1_1wf_1_1mp_1_1is__nothrow__invocable__r.html">csl::wf::mp::is_nothrow_invocable_r</a>&lt;</div>
<div class="line">  C,</div>
<div class="line">  <span class="keyword">const</span> functor,</div>
<div class="line">  ttps&lt;C&gt;</div>
<div class="line">&gt;);</div>
<div class="line"><span class="comment">// not noexcept because of `noexcept(std::same_as&lt;T, C&gt;)`, where T = A</span></div>
<div class="line">static_assert(not <a class="code" href="structcsl_1_1wf_1_1mp_1_1is__nothrow__invocable__r.html">csl::wf::mp::is_nothrow_invocable_r</a>&lt;</div>
<div class="line">  C,</div>
<div class="line">  <span class="keyword">const</span> functor,</div>
<div class="line">  ttps&lt;A&gt;</div>
<div class="line">&gt;);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md52"></a>
invoke_result</h2>
<div class="fragment"><div class="line">invoke_result&lt;F, [ttps&lt;...&gt;,] args_types...&gt;</div>
</div><!-- fragment --><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">parameter </th><th class="markdownTableHeadNone">description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>F</code> </td><td class="markdownTableBodyNone">A type, most likely a functor  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>ttps&lt;...&gt;</code> </td><td class="markdownTableBodyNone">Template-type-parameters  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>args_types</code> </td><td class="markdownTableBodyNone">Parameters types.<br  />
Must be complete types usable in an unevaluated context.  </td></tr>
</table>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">member-type </th><th class="markdownTableHeadNone">description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">type </td><td class="markdownTableBodyNone">deduced type of an invoke expression  </td></tr>
</table>
<hr  />
<p>Deduce the return type yield by an invoke expression, at compile time.</p>
<p>Similar to its STL counterpat <a href="https://en.cppreference.com/w/cpp/types/result_of">std::invoke_result</a>, or <a href="https://en.cppreference.com/w/cpp/types/result_of">std::result_of</a> for previous standards, but with an additiona non-mandatory template-parameter-type which is a possibly cvref-qualified <code>ttps&lt;...&gt;</code>, meant to pass template-type-parameters to the functors in order to build the invoke expression.</p>
<p>If the invoke expression is not valid, then the member-type <code>type</code> is not defined.</p>
<hr  />
<p>Example :</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keyword">auto</span> func = [](char) -&gt; <span class="keywordtype">int</span> { <span class="keywordflow">return</span> {}; };</div>
<div class="line">  <span class="keyword">using</span> F = decltype(func);</div>
<div class="line"> </div>
<div class="line">  static_assert(std::is_same_v&lt;</div>
<div class="line">    <span class="keywordtype">int</span>,</div>
<div class="line">    invoke_result&lt;F, char&gt;</div>
<div class="line">  &gt;);</div>
<div class="line">}</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">auto</span> func = []&lt;<span class="keyword">typename</span>...&gt;(char) -&gt; <span class="keywordtype">int</span> { <span class="keywordflow">return</span> {}; };</div>
<div class="line">  <span class="keyword">using</span> F = decltype(func);</div>
<div class="line"> </div>
<div class="line">  static_assert(std::is_same_v&lt;</div>
<div class="line">    <span class="keywordtype">int</span>,</div>
<div class="line">    invoke_result&lt;F, ttps&lt;&gt;, <span class="keywordtype">char</span>&gt;</div>
<div class="line">  &gt;);</div>
<div class="line">  static_assert(std::is_same_v&lt;</div>
<div class="line">    <span class="keywordtype">int</span>,</div>
<div class="line">    invoke_result&lt;F, ttps&lt;double, float&gt;, <span class="keywordtype">char</span>&gt;</div>
<div class="line">  &gt;);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md55"></a>
is_applyable</h2>
<div class="fragment"><div class="line">is_applyable&lt;F, [ttps&lt;...&gt;,] tuple_type&gt;</div>
<div class="line">is_applyable&lt;F, tuple_type&lt;[ttps&lt;...&gt;,] ...&gt; &gt;</div>
</div><!-- fragment --><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">parameter </th><th class="markdownTableHeadNone">description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>F</code> </td><td class="markdownTableBodyNone">A type, most likely a functor  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>ttps&lt;...&gt;</code> </td><td class="markdownTableBodyNone">Template-type-parameters  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>tuple_type</code> </td><td class="markdownTableBodyNone">Tuple-like type, containing invocation parameters.<br  />
Must meet the <code>csl::wf::concepts::tuple_interface</code> concept requirements  </td></tr>
</table>
<hr  />
<p>Similar to <a href="#is_invocable">is_invocable</a>, but detects if the callable object F is invocable using a tuple of argument.</p>
<p>Those can be passed in two different way, either as :</p>
<ul>
<li>Second non-mandatory template-type-parameter, <br  />
 <code>is_applyable&lt;F, [ttps&lt;...&gt;,] tuple_type&gt;</code></li>
<li>First template-type-parameter of the tuple_type itself, <br  />
 <code>is_applyable&lt;F, tuple_type&lt;ttps&lt;...&gt;, ...&gt; &gt;</code></li>
</ul>
<hr  />
<p>Example</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keyword">auto</span> func = [](A, B){};</div>
<div class="line">  <span class="keyword">using</span> F = decltype(func);</div>
<div class="line">  static_assert(mp::is_applyable_v&lt;F,         std::tuple&lt;A, B&gt;&gt;);</div>
<div class="line">  static_assert(mp::is_applyable_v&lt;F, ttps&lt;&gt;, std::tuple&lt;A, B&gt;&gt;);</div>
<div class="line">}</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">auto</span> func = []&lt;<span class="keyword">typename</span>&gt;(A, B){};</div>
<div class="line">  <span class="keyword">using</span> F = decltype(func);</div>
<div class="line">  static_assert(mp::is_applyable_v&lt;F, ttps&lt;int&gt;, std::tuple&lt;A, B&gt;&gt;);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md58"></a>
is_nothrow_applyable</h2>
<div class="fragment"><div class="line">is_nothrow_applyable&lt;F, [ttps&lt;...&gt;,] tuple_type&gt;</div>
<div class="line">is_nothrow_applyable&lt;F, tuple_type&lt;[ttps&lt;...&gt;,] ...&gt; &gt;</div>
</div><!-- fragment --><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">parameter </th><th class="markdownTableHeadNone">description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>F</code> </td><td class="markdownTableBodyNone">A type, most likely a functor  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>ttps&lt;...&gt;</code> </td><td class="markdownTableBodyNone">Template-type-parameters  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>tuple_type</code> </td><td class="markdownTableBodyNone">Tuple-like type, containing invocation parameters.<br  />
Must meet the <code>csl::wf::concepts::tuple_interface</code> concept requirements  </td></tr>
</table>
<hr  />
<p>Similar to <a href="#is_nothrow_invocable">is_nothrow_invocable</a>, but detects if :</p><ul>
<li>the callable object F is invocable using a tuple of argument</li>
<li><b>and</b> is not known to throw any exception</li>
</ul>
<hr  />
<p>Example</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keyword">struct </span>F {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(A, B){} <span class="comment">// 1</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt;</div>
<div class="line">    <span class="keywordtype">void</span> operator()(A, B) noexcept {} <span class="comment">// 2</span></div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  static_assert(not mp::is_applyable_v&lt;F,         std::tuple&lt;A, B&gt;&gt;);     <span class="comment">// 1</span></div>
<div class="line">  static_assert(not mp::is_applyable_v&lt;F, ttps&lt;&gt;, std::tuple&lt;A, B&gt;&gt;);     <span class="comment">// 1</span></div>
<div class="line">  static_assert(    mp::is_applyable_v&lt;F, ttps&lt;int&gt;, std::tuple&lt;A, B&gt;&gt;);  <span class="comment">// 2</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md61"></a>
is_applyable_before</h2>
<div class="fragment"><div class="line"><span class="comment">// definitions</span></div>
<div class="line">is_applyable_before&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>...&gt;;</div>
<div class="line"><span class="comment">// specialization</span></div>
<div class="line">is_applyable_before&lt;F, ttps&lt;f_ts...&gt;, tuple_type, func_args_t...&gt;;</div>
<div class="line">is_applyable_before&lt;F, tuple_type, func_args_t...&gt;;</div>
</div><!-- fragment --><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">parameter </th><th class="markdownTableHeadNone">description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>F</code> </td><td class="markdownTableBodyNone">A type, most likely a functor  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>ttps&lt;...&gt;</code> </td><td class="markdownTableBodyNone">Template-type-parameters  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>tuple_type</code> </td><td class="markdownTableBodyNone">Tuple-like type, containing invocation parameters.<br  />
Must meet the <code>csl::wf::concepts::tuple_interface</code> concept requirements  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>func_args_t</code> </td><td class="markdownTableBodyNone">Additional template-type-parameters.<br  />
Expanded <b>after</b> <code>tuple_type</code>  </td></tr>
</table>
<hr  />
<p>Same as <a href="#is_applyable">is_applyable</a>, but provide the opportunity for the user to add extra parameters to the underlying functor invocation. Nb : the parameters contained in the tuple-like type <code>tuple_type</code> are expand <b>before</b> <code>func_args_t</code> in the signature.</p>
<p>Internally use <code>is_invocable</code> to detect if such expression is true :</p><ul>
<li>```cpp is_invocable_v&lt;F, ttps&lt;f_ts...&gt;, decltype(std::get&lt;indexes&gt;(std::declval&lt;tuple_type&gt;()))..., func_args_t...&gt;; <div class="fragment"><div class="line">---</div>
<div class="line"> </div>
<div class="line">Example</div>
<div class="line"> </div>
<div class="line">```cpp</div>
<div class="line">auto f = [](B, A){};</div>
<div class="line">using F = decltype(f);</div>
<div class="line"> </div>
<div class="line">static_assert(is_applyable_before_v&lt;F, std::tuple&lt;&gt;, B, A&gt;);</div>
<div class="line">static_assert(is_applyable_before_v&lt;F, std::tuple&lt;B&gt;, A&gt;);</div>
<div class="line">static_assert(is_applyable_before_v&lt;F, std::tuple&lt;B, A&gt;&gt;);</div>
<div class="line"> </div>
<div class="line">static_assert(is_applyable_before_v&lt;F, ttps&lt;&gt;, std::tuple&lt;&gt;, B, A&gt;);</div>
<div class="line">static_assert(is_applyable_before_v&lt;F, ttps&lt;&gt;, std::tuple&lt;B&gt;, A&gt;);</div>
<div class="line">static_assert(is_applyable_before_v&lt;F, ttps&lt;&gt;, std::tuple&lt;B, A&gt;&gt;);</div>
</div><!-- fragment --></li>
</ul>
<h2><a class="anchor" id="autotoc_md63"></a>
is_nothrow_applyable_before</h2>
<p>Same as <a href="#is_applyable_before">is_applyable_before</a>, but internally use <a href="#is_nothrow_invocable">is_nothrow_invocable</a> instead of <a href="#is_invocable">is_invocable</a>, <br  />
 so the evaluated invocation expression must NOT be known to throw.</p>
<hr  />
<p>Example</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> f = []&lt;<span class="keyword">typename</span> T&gt;(T) noexcept {};</div>
<div class="line"><span class="keyword">using</span> F = decltype(f);</div>
<div class="line"> </div>
<div class="line">static_assert(is_applyable_before_v&lt;F, std::tuple&lt;&gt;, B&gt;);</div>
<div class="line">static_assert(is_applyable_before_v&lt;F, std::tuple&lt;B&gt;&gt;);</div>
<div class="line">static_assert(is_applyable_before_v&lt;F, ttps&lt;&gt;, std::tuple&lt;&gt;, B&gt;);</div>
<div class="line">static_assert(is_applyable_before_v&lt;F, ttps&lt;B&gt;, std::tuple&lt;B&gt;&gt;);</div>
<div class="line"> </div>
<div class="line">static_assert(is_nothrow_applyable_before_v&lt;F, std::tuple&lt;&gt;, B&gt;);</div>
<div class="line">static_assert(is_nothrow_applyable_before_v&lt;F, std::tuple&lt;B&gt;&gt;);</div>
<div class="line">static_assert(is_nothrow_applyable_before_v&lt;F, ttps&lt;&gt;, std::tuple&lt;&gt;, B&gt;);</div>
<div class="line">static_assert(is_nothrow_applyable_before_v&lt;F, ttps&lt;B&gt;, std::tuple&lt;B&gt;&gt;);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md65"></a>
is_applyable_after</h2>
<div class="fragment"><div class="line"><span class="comment">// definitions</span></div>
<div class="line">is_applyable_after&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>...&gt;;</div>
<div class="line"><span class="comment">// specialization</span></div>
<div class="line">is_applyable_after&lt;F, ttps&lt;f_ts...&gt;, tuple_type, func_args_t...&gt;;</div>
<div class="line">is_applyable_after&lt;F, tuple_type, func_args_t...&gt;;</div>
</div><!-- fragment --><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">parameter </th><th class="markdownTableHeadNone">description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>F</code> </td><td class="markdownTableBodyNone">A type, most likely a functor  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>ttps&lt;...&gt;</code> </td><td class="markdownTableBodyNone">Template-type-parameters  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>tuple_type</code> </td><td class="markdownTableBodyNone">Tuple-like type, containing invocation parameters.<br  />
Must meet the <code>csl::wf::concepts::tuple_interface</code> concept requirements  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>func_args_t</code> </td><td class="markdownTableBodyNone">Additional template-type-parameters.<br  />
Expanded <b>before</b> <code>tuple_type</code>  </td></tr>
</table>
<p>Same as <a href="#is_applyable_before">is_applyable_before</a>, but parameters contained in the tuple-like type are expand <b>after</b> <code>func_args_t</code>.</p>
<p>Internally use <code>is_invocable</code> to detect if such expression is true :</p>
<ul>
<li>```cpp is_invocable_v&lt;F, ttps&lt;f_ts...&gt;, func_args_t..., decltype(std::get&lt;indexes&gt;(std::declval&lt;tuple_type&gt;()))...&gt;; <div class="fragment"><div class="line">---</div>
<div class="line"> </div>
<div class="line">Example</div>
<div class="line"> </div>
<div class="line">```cpp</div>
<div class="line">auto f = [](A, B){};</div>
<div class="line">using F = decltype(f);</div>
<div class="line"> </div>
<div class="line">static_assert(is_applyable_after_v&lt;F, std::tuple&lt;&gt;, A, B&gt;);</div>
<div class="line">static_assert(is_applyable_after_v&lt;F, std::tuple&lt;B&gt;, A&gt;);</div>
<div class="line">static_assert(is_applyable_after_v&lt;F, std::tuple&lt;A, B&gt;&gt;);</div>
<div class="line"> </div>
<div class="line">static_assert(is_applyable_after_v&lt;F, ttps&lt;&gt;, std::tuple&lt;&gt;, A, B&gt;);</div>
<div class="line">static_assert(is_applyable_after_v&lt;F, ttps&lt;&gt;, std::tuple&lt;B&gt;, A&gt;);</div>
<div class="line">static_assert(is_applyable_after_v&lt;F, ttps&lt;&gt;, std::tuple&lt;A, B&gt;&gt;);</div>
</div><!-- fragment --></li>
</ul>
<h2><a class="anchor" id="autotoc_md66"></a>
is_nothrow_applyable_after</h2>
<p>Same as <a href="#is_applyable_after">is_applyable_after</a>, but internally use <a href="#is_nothrow_invocable">is_nothrow_invocable</a> instead of <a href="#is_invocable">is_invocable</a>, <br  />
 so the evaluated invocation expression must NOT be known to throw.</p>
<hr  />
<p>Example</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> f = [](A, B) noexcept {};</div>
<div class="line"><span class="keyword">using</span> F = decltype(f);</div>
<div class="line"> </div>
<div class="line">static_assert(is_applyable_after_v&lt;F, std::tuple&lt;&gt;, A, B&gt;);</div>
<div class="line">static_assert(is_applyable_after_v&lt;F, std::tuple&lt;B&gt;, A&gt;);</div>
<div class="line">static_assert(is_applyable_after_v&lt;F, std::tuple&lt;A, B&gt;&gt;);</div>
<div class="line"> </div>
<div class="line">static_assert(is_applyable_after_v&lt;F, ttps&lt;&gt;, std::tuple&lt;&gt;, A, B&gt;);</div>
<div class="line">static_assert(is_applyable_after_v&lt;F, ttps&lt;&gt;, std::tuple&lt;B&gt;, A&gt;);</div>
<div class="line">static_assert(is_applyable_after_v&lt;F, ttps&lt;&gt;, std::tuple&lt;A, B&gt;&gt;);</div>
<div class="line"> </div>
<div class="line">static_assert(is_nothrow_applyable_after_v&lt;F, std::tuple&lt;&gt;, A, B&gt;);</div>
<div class="line">static_assert(is_nothrow_applyable_after_v&lt;F, std::tuple&lt;B&gt;, A&gt;);</div>
<div class="line">static_assert(is_nothrow_applyable_after_v&lt;F, std::tuple&lt;A, B&gt;&gt;);</div>
<div class="line"> </div>
<div class="line">static_assert(is_nothrow_applyable_after_v&lt;F, ttps&lt;&gt;, std::tuple&lt;&gt;, A, B&gt;);</div>
<div class="line">static_assert(is_nothrow_applyable_after_v&lt;F, ttps&lt;&gt;, std::tuple&lt;B&gt;, A&gt;);</div>
<div class="line">static_assert(is_nothrow_applyable_after_v&lt;F, ttps&lt;&gt;, std::tuple&lt;A, B&gt;&gt;);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md68"></a>
apply_result</h2>
<div class="fragment"><div class="line"><span class="comment">// definition</span></div>
<div class="line"><span class="keyword">struct </span>apply_result&lt;typename F, typename...&gt;;</div>
<div class="line"><span class="comment">// specializations</span></div>
<div class="line"><span class="keyword">struct </span>apply_result&lt;F, tuple_type&gt;; <span class="comment">// 1</span></div>
<div class="line"><span class="keyword">struct </span>apply_result&lt;F, ttps_type, tuple_type&gt;; <span class="comment">// 2</span></div>
<div class="line"><span class="keyword">struct </span>apply_result&lt;F, ttps&lt;ttps_args...&gt;, concepts::tupleinterface_not_starting_with_ttps&gt;; <span class="comment">// 3</span></div>
</div><!-- fragment --><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">parameter </th><th class="markdownTableHeadNone">description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>F</code> </td><td class="markdownTableBodyNone">A type, most likely a functor  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>ttps&lt;...&gt;</code> </td><td class="markdownTableBodyNone">Template-type-parameters  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>tuple_type</code> </td><td class="markdownTableBodyNone">Tuple-like type, containing invocation parameters.<br  />
Must meet the <code>csl::wf::concepts::tuple_interface</code> concept requirements  </td></tr>
</table>
<hr  />
<p>Deduces the type yield by an <a href="#apply">apply</a> expression, in a similar way in which <a href="#invoke_result">invoke_result</a> deduce the type of an <a href="#invoke">invoke</a> expression.</p>
<p>Non-mandatory additional parameter <code>ttps&lt;...&gt;</code> can be pass to represents template-type-paramters for the underlying functor value call, either as an :</p>
<ul>
<li>Additional <code>ttps&lt;...&gt;</code> template-parameter, using (2) specialization.</li>
<li>Additional first tuple element of <code>tuple_type</code>, using (3) specialization.</li>
</ul>
<p>Note that both way to pass <code>ttps&lt;...&gt;</code> can't be used at the same time.</p>
<hr  />
<p>Example</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>A{}; <span class="keyword">struct </span>B{};</div>
<div class="line"><span class="keyword">auto</span> func = []&lt;<span class="keyword">typename</span> ... Ts&gt;(A, B) -&gt; std::common_type_t&lt;Ts...&gt; { <span class="keywordflow">return</span> {}; };</div>
<div class="line"><span class="keyword">using</span> F = decltype(func);</div>
<div class="line"> </div>
<div class="line">static_assert(std::is_same_v&lt;</div>
<div class="line">  <span class="keywordtype">int</span>,</div>
<div class="line">  apply_result_t&lt;F, std::tuple&lt;A, B&gt;&gt;</div>
<div class="line">&gt;); <span class="comment">// error : invalid use of incomplete type std::common_type&lt;Ts...&gt; where [ Ts = ] (empty)</span></div>
<div class="line"> </div>
<div class="line">static_assert(std::is_same_v&lt;</div>
<div class="line">  <span class="keywordtype">int</span>,</div>
<div class="line">  apply_result_t&lt;F, ttps&lt;char, bool, int&gt;, std::tuple&lt;A, B&gt;&gt;</div>
<div class="line">&gt;);</div>
<div class="line">static_assert(std::is_same_v&lt;</div>
<div class="line">  <span class="keywordtype">int</span>,</div>
<div class="line">  apply_result_t&lt;F, std::tuple&lt;ttps&lt;char, bool, int&gt;, A, B&gt;&gt;</div>
<div class="line">&gt;);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md71"></a>
is_invocable_with</h2>
<div class="fragment"><div class="line"><span class="comment">// definition</span></div>
<div class="line"><span class="keyword">struct </span>is_invocable_with&lt;typename F, typename ...&gt;;</div>
<div class="line"><span class="comment">// specializations</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> ... ttps_args, <span class="keyword">typename</span> ... args_types&gt;</div>
<div class="line"><span class="keyword">struct </span>is_invocable_with&lt;F, ttps&lt;ttps_args...&gt;, args&lt;args_types...&gt;&gt;</div>
</div><!-- fragment --><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">parameter </th><th class="markdownTableHeadNone">description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>F</code> </td><td class="markdownTableBodyNone">A type, most likely a functor  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>ttps&lt;...&gt;</code> </td><td class="markdownTableBodyNone">Template-type-parameters  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>args&lt;...&gt;</code> </td><td class="markdownTableBodyNone">Parameters  </td></tr>
</table>
<hr  />
<p>Similar to <a href="#is_invocable">is_invocable</a>/<a href="#is_applyable">is_applyable</a>, but wraps both template-type-parameters and parameters respectively as <code>ttps</code> and <code>args</code> template-type-parameters. <br  />
</p>
<p>More convenient for pack_traits - <em>like filtering</em> - applications</p>
<p>Less restrictive than <code>is_applyable</code>, as <code>args&lt;...&gt;</code> is <b>NOT</b> requiered to match <code>TupleInterface</code>. <br  />
 Also, easier to handle types that does not fit in <code>std::tuple</code>, <code>array</code> and <code>paires</code>, like <code>void</code>.</p>
<hr  />
<p>Example :</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>F {</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...&gt;</div>
<div class="line">  <span class="keywordtype">void</span> operator()(){}</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">  <span class="keywordtype">void</span> operator()(<span class="keywordtype">int</span>) <span class="keyword">const</span> noexcept {}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">static_assert(invocable_with&lt;F, ttps&lt;&gt;, args&lt;&gt;&gt;);</div>
<div class="line">static_assert(invocable_with&lt;F, ttps&lt;char, bool&gt;, args&lt;&gt;&gt;);</div>
<div class="line">static_assert(invocable_with&lt;<span class="keyword">const</span> F, ttps&lt;char&gt;, args&lt;int&gt;&gt;);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md74"></a>
is_nothrow_invocable_with</h2>
<p>Similar to <a href="#is_invocable_with">is_invocable_with</a>, but the underlying detected call must not be known to throw any exception.</p>
<hr  />
<p>Example :</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>F {</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...&gt;</div>
<div class="line">  <span class="keywordtype">void</span> operator()(){}</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">  <span class="keywordtype">void</span> operator()(<span class="keywordtype">int</span>) <span class="keyword">const</span> noexcept {}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">static_assert(not nothrow_invocable_with&lt;F, ttps&lt;&gt;, args&lt;&gt;&gt;);</div>
<div class="line">static_assert(nothrow_invocable_with&lt;<span class="keyword">const</span> F, ttps&lt;char&gt;, args&lt;int&gt;&gt;);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md76"></a>
bind_front</h1>
<p>Factory for <code>front_binder</code>. <br  />
 Like <code>std::bind_front</code>, preserve cvref-qualifiers correctness.</p>
<p>Signature :</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ... ttps_bounded_args_t, <span class="keyword">typename</span> F, <span class="keyword">typename</span> ... args_t&gt;</div>
<div class="line">constexpr <span class="keyword">auto</span> bind_front(F&amp;&amp; f, args_t &amp;&amp; ... args);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md77"></a>
front_bindable (concept)</h2>
<h2><a class="anchor" id="autotoc_md78"></a>
front_binder (type)</h2>
<h1><a class="anchor" id="autotoc_md79"></a>
invocation policies</h1>
<h2><a class="anchor" id="autotoc_md80"></a>
csl::wf::invoke_policy::allow_discard</h2>
<h2><a class="anchor" id="autotoc_md81"></a>
csl::wf::invoke_policy::nodiscard</h2>
<h1><a class="anchor" id="autotoc_md82"></a>
chain</h1>
<h2><a class="anchor" id="autotoc_md83"></a>
&lt;tt&gt;mp::chain_trait&lt;typename ... Fs&gt;&lt;/tt&gt;</h2>
<h2><a class="anchor" id="autotoc_md84"></a>
chain_invoke</h2>
<h2><a class="anchor" id="autotoc_md85"></a>
chain_invoke_nodiscard</h2>
<h2><a class="anchor" id="autotoc_md86"></a>
chain_invocable (concept)</h2>
<h2><a class="anchor" id="autotoc_md87"></a>
route (type)</h2>
<h3><a class="anchor" id="autotoc_md88"></a>
get&lt;index&gt;(instance_of&lt;route&gt;)</h3>
<h1><a class="anchor" id="autotoc_md89"></a>
overload</h1>
<h1><a class="anchor" id="autotoc_md90"></a>
repeater</h1>
<h1><a class="anchor" id="autotoc_md91"></a>
function_ref&lt;T&gt;</h1>
<p>Wraps a reference to a value which might be a functor, <br  />
 in a similar fashion to <a href="https://en.cppreference.com/w/cpp/utility/functional/reference_wrapper">std::reference_wrapper</a>. <br  />
 However, in opposition to <code>std::reference_wrapper::operator()</code>, <code>function_ref&lt;T&gt;::operator()</code>-s are conditionaly generated and internally call <code>csl::wf::invoke</code> with a similar signature (see description hereunder).</p>
<p>In opposition to <a href="#function_viewt"><code>function_view&lt;T&gt;</code></a>, a <code>function_ref&lt;T&gt;</code> value si copyable and reassignable using its <code>operator=</code> or <code>swap</code> member-functions.</p>
<blockquote class="doxtable">
<p>This is somehow similar to the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0792r5.html">std::function_ref proposal</a>, <br  />
 but designed &amp; implemented according to <code>csl::wf</code> philosophy. <br  />
 See [](#philosophy&ndash;design-choices) and [](#invocation-utilities) sections. </p>
</blockquote>
<p>To avoid any dangling reference, a <code>function_ref&lt;T&gt;</code> value's lifetime must be greater than the underlying data it refers to.</p>
<p><b>Member types</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">type </th><th class="markdownTableHeadNone">definition  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">type </td><td class="markdownTableBodyNone">T  </td></tr>
</table>
<p><b>Member functions - constructors</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">name </th><th class="markdownTableHeadNone">description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>constexpr explicit function_ref(auto &amp;&amp; value) noexcept</code> </td><td class="markdownTableBodyNone">by-value constructor<br  />
If <code>value</code> is a pointer, then it can't be equal to <code>nullptr</code>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>constexpr function_ref(const function_ref &amp; other) noexcept = default;</code> </td><td class="markdownTableBodyNone">copy-constructor  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>constexpr function_ref(function_ref &amp;&amp;) noexcept = default;</code> </td><td class="markdownTableBodyNone">move-constructor  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>constexpr function_ref() = delete;</code> </td><td class="markdownTableBodyNone">default constructor  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>constexpr ~function_ref() = default;</code> </td><td class="markdownTableBodyNone">default destructor  </td></tr>
</table>
<p><b>Member functions - assign</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">name </th><th class="markdownTableHeadNone">description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>constexpr function_ref &amp; operator=(function_ref &amp;&amp;) noexcept = default;</code> </td><td class="markdownTableBodyNone">move-assign  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>constexpr function_ref &amp; operator=(const function_ref &amp;) noexcept = default;</code> </td><td class="markdownTableBodyNone">copy-assign  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>constexpr void swap(function_ref &amp; other) noexcept</code> </td><td class="markdownTableBodyNone">swap  </td></tr>
</table>
<p><b>Member functions - accessors</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">name </th><th class="markdownTableHeadNone">description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>constexpr explicit operator /*cv-qualifier*/ type&amp;() /*cv-qualifier*/ noexcept</code> </td><td class="markdownTableBodyNone">Underlying value  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>constexpr /*cv-qualifier*/ F&amp; get() /*cv-qualifier*/ noexcept</code> </td><td class="markdownTableBodyNone">Underlying value  </td></tr>
</table>
<p><b>Member functions - operations</b></p>
<blockquote class="doxtable">
<p>The following <code>operator()</code> overload are conditionaly generated. </p>
</blockquote>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">name </th><th class="markdownTableHeadNone">description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>template &lt;typename ... ttps_args&gt;</code><br  />
<code>constexpr decltype(auto) operator()(auto &amp;&amp; ... args) /*cv-ref-qualifiers*/</code> </td><td class="markdownTableBodyNone">Forward parameters to <a href="#invoke"><code>csl::wf::invoke</code></a>, and returns the invocation's result.  </td></tr>
</table>
<p><b>Non-member functions</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">name </th><th class="markdownTableHeadNone">description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>template &lt;typename F&gt;</code><br  />
<code>constexpr void swap(function_ref&lt;F&gt; &amp; lhs, function_ref&lt;F&gt; &amp; rhs)</code> </td><td class="markdownTableBodyNone">swap  </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md92"></a>
function_view&lt;T&gt;</h1>
<p>Same as <a href="#function_reft"><code>function_ref&lt;T&gt;</code></a>, but <b>not</b> reassignable.</p>
<h1><a class="anchor" id="autotoc_md93"></a>
eDSL</h1>
<h2><a class="anchor" id="autotoc_md94"></a>
_times (literals)</h2>
<h2><a class="anchor" id="autotoc_md95"></a>
factories</h2>
<h3><a class="anchor" id="autotoc_md96"></a>
make_continuation</h3>
<h3><a class="anchor" id="autotoc_md97"></a>
make_condition</h3>
<h3><a class="anchor" id="autotoc_md98"></a>
make_repetition</h3>
<h2><a class="anchor" id="autotoc_md99"></a>
operators</h2>
<h3><a class="anchor" id="autotoc_md100"></a>
&lt;tt&gt;operator|&lt;/tt&gt; (pipe operator)</h3>
<h4><a class="anchor" id="autotoc_md101"></a>
F1 | F2</h4>
<h4><a class="anchor" id="autotoc_md102"></a>
F | ref</h4>
<p>Returns a value of type <a href="#function_reft"><code>function_ref&lt;T&gt;</code></a>.</p>
<h4><a class="anchor" id="autotoc_md103"></a>
F | cref</h4>
<p>Returns a value of type <a href="#function_reft"><code>function_ref&lt;const T&gt;</code></a>, where type is const-qualified.</p>
<h4><a class="anchor" id="autotoc_md104"></a>
F | view</h4>
<p>Returns a value of type <a href="#function_viewt"><code>function_view&lt;T&gt;</code></a>.</p>
<h3><a class="anchor" id="autotoc_md105"></a>
&lt;tt&gt;operator&gt;&gt;=&lt;/tt&gt; (right-shift-assign operator)</h3>
<h3><a class="anchor" id="autotoc_md106"></a>
&lt;tt&gt;operator*&lt;/tt&gt; (star operator)</h3>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="astructcsl_1_1wf_1_1mp_1_1ttps_html"><div class="ttname"><a href="structcsl_1_1wf_1_1mp_1_1ttps.html">csl::wf::mp::ttps</a></div><div class="ttdef"><b>Definition:</b> wf.hpp:189</div></div>
<div class="ttc" id="astructcsl_1_1wf_1_1mp_1_1is__nothrow__invocable__r_html"><div class="ttname"><a href="structcsl_1_1wf_1_1mp_1_1is__nothrow__invocable__r.html">csl::wf::mp::is_nothrow_invocable_r</a></div><div class="ttdef"><b>Definition:</b> wf.hpp:288</div></div>
<div class="ttc" id="astructcsl_1_1wf_1_1mp_1_1is__invocable_html"><div class="ttname"><a href="structcsl_1_1wf_1_1mp_1_1is__invocable.html">csl::wf::mp::is_invocable</a></div><div class="ttdef"><b>Definition:</b> wf.hpp:234</div></div>
<div class="ttc" id="astructcsl_1_1wf_1_1mp_1_1is__nothrow__invocable_html"><div class="ttname"><a href="structcsl_1_1wf_1_1mp_1_1is__nothrow__invocable.html">csl::wf::mp::is_nothrow_invocable</a></div><div class="ttdef"><b>Definition:</b> wf.hpp:250</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
