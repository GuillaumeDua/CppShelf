<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>üì¶ csl::ag: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="github_emoji_unicode_1f4e6.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">üì¶ csl::ag
   </div>
   <div id="projectbrief">Tuple-like interface (get/element/size) for aggregates type, and much more. https://github.com/GuillaumeDua/CppShelf/</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">üì¶ csl::ag Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>&lt;script type="text/javascript" src="$relpath^doxygen-awesome-darkmode-toggle.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="$relpath^doxygen-awesome-fragment-copy-button.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; DoxygenAwesomeDarkModeToggle.init(); DoxygenAwesomeFragmentCopyButton.init(); &lt;/script&gt;</p>
<div style="position: absolute; top: 0; right: 0;"> <a href="https://github.com/GuillaumeDua/CppShelf"><img src="https://github.blog/wp-content/uploads/2008/12/forkme_right_red_aa0000.png?resize=149%2C149" alt="Fork me on GitHub" loading="lazy" width="149" height="149" class="attachment-full size-full" data-recalc-dims="1" align="right" style="position: relative; top: 0; right: 0; z-index: 1;" class="inline"/> </a> <a href="https://guillaumedua.github.io/CppShelf/"><img src="https://github.com/GuillaumeDua/CppShelf/blob/main/docs/details/images/gh-pages-logo.png?raw=true" alt="Check documentation on GitHub-pages" loading="lazy" align="right" class="attachment-full size-full" height="40" style="position: absolute; top: 0; right: 0; z-index: 3;" class="inline"/> </a> </div><h1><a class="anchor" id="autotoc_md0"></a>
Overall presentation</h1>
<p>The goal of <code>csl::ag</code> is to offer convenient ways to manipulate aggregate types.</p>
<h2><a class="anchor" id="autotoc_md1"></a>
Overview demo</h2>
<p>The following example demonstrates some of the features which are available in <code>csl::ag</code>.</p>
<table class="doxtable">
<tr>
<th>C++ code ( <a href="https://godbolt.org/z/x1dGTWddK">Try me on compiler-explorer <img src="https://github.com/GuillaumeDua/CppShelf/blob/main/docs/details/images/compiler-explorer.png?raw=true" alt="" align="left" width="20" height="20" style="Padding: 2px 4px 0px 0px" class="inline"/> </a> ) </th><th>Console output  </th></tr>
<tr>
<td><p class="starttd"></p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>S { <span class="keywordtype">char</span> c; <span class="keywordtype">int</span> i; };</div>
<div class="line"> </div>
<div class="line">static_assert(</div>
<div class="line">    csl::ag::concepts::aggregate&lt;S&gt; and</div>
<div class="line">    csl::ag::size_v&lt;S&gt; == 2</div>
<div class="line">);</div>
<div class="line">static_assert(std::same_as&lt;<span class="keywordtype">char</span>,  csl::ag::element_t&lt;0, S&gt;&gt;);</div>
<div class="line">static_assert(std::same_as&lt;<span class="keywordtype">int</span>,   csl::ag::element_t&lt;1, S&gt;&gt;);</div>
<div class="line"> </div>
<div class="line">S value{ <span class="charliteral">&#39;A&#39;</span>, 41 }; ++std::get&lt;1&gt;(value);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>csl::ag::io;</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;value: &quot;</span> &lt;&lt; value &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line"><span class="comment">// (wip) compatibility with `fmt` and `std::print` will be available soon</span></div>
</div><!-- fragment --><p class="endtd"></p>
</td><td><p class="starttd"></p>
<div class="fragment"><div class="line">value: S&amp; : {</div>
<div class="line">   [0] char : A</div>
<div class="line">   [1] int : 42</div>
<div class="line">}</div>
</div><!-- fragment --><p class="endtd"></p>
</td></tr>
</table>
<h2><a class="anchor" id="autotoc_md2"></a>
Introduction</h2>
<p>By default, the C++ standard allow structured-binding for aggregate types.</p>
<table class="doxtable">
<tr>
<th>C++ code ( <a href="https://godbolt.org/z/3EcK9Wc7h">Try me on compiler-explorer <img src="https://github.com/GuillaumeDua/CppShelf/blob/main/docs/details/images/compiler-explorer.png?raw=true" alt="" align="left" width="20" height="20" style="Padding: 2px 4px 0px 0px" class="inline"/> </a> )  </th></tr>
<tr>
<td><p class="starttd"></p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>type{ <span class="keywordtype">int</span> i; <span class="keywordtype">char</span> c; };</div>
<div class="line"><span class="keyword">auto</span> value = type{ 42, <span class="charliteral">&#39;A&#39;</span> }; <span class="comment">// NOLINT</span></div>
<div class="line"> </div>
<div class="line">[[maybe_unused]] <span class="keyword">auto</span> &amp;&amp; [ v0, v1 ] = value;</div>
<div class="line">assert(v0 == 42);   <span class="comment">// pass</span></div>
<div class="line">assert(v1 == <span class="charliteral">&#39;A&#39;</span>);  <span class="comment">// pass</span></div>
</div><!-- fragment --><p class="endtd"></p>
</td></tr>
</table>
<p>However, there is no - <em>simple</em> - way to access the following informations for a given aggregate type or value :</p>
<ul>
<li>The count of fields</li>
<li>Access a field's value by index</li>
<li>Iterate over fields</li>
</ul>
<p>This library provides a way to obtain such information, and internally use it to provide convenient high-level conversions and printing functions.</p>
<hr  />
<p>This library is divided in five distinct parts :</p>
<ul>
<li><a href="#aggregate-related-concepts">#1</a> Aggregates-related concepts</li>
<li><a href="#aggregate-related-type-traits">#2</a> Aggregates-related type-traits</li>
<li><a href="#to-tuple-conversion-for-aggregate-types">#3</a> Conversion to tuples for aggregate types (owning or not)</li>
<li><a href="#tuplelike-interface-for-aggregates">#4</a> A tuplelike interface for aggregates types</li>
<li><a href="#pretty-printing">#5 (WIP)</a> Pretty-printing (using <code>std::ostream &amp; operator&lt;&lt;</code> overloads or <code>fmt</code>)</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md5"></a>
Philosophy &amp; design choices</h2>
<p>The key idea of this library is to ease iterations over aggregates's member-variables, <br  />
 which is especially convenient when dealing with <b>reflection</b> and <b>serialization</b>.</p>
<ul>
<li><code><a class="el" href="structcsl_1_1ag_1_1size.html">csl::ag::size</a>&lt;T&gt;</code> gives the fields count in a given aggregate type type <br  />
 (or <a href="https://en.cppreference.com/w/cpp/utility/tuple/tuple_size">std::tuple_size_v</a> after a <code>as_tuple</code> or <code>as_tuple_view</code> conversion)</li>
<li><code>csl::ag::get&lt;size_t N&gt;(aggregate auto value)</code> allows per-field access, in a similar way to <a href="https://en.cppreference.com/w/cpp/utility/tuple/get">std::get&lt;N&gt;</a> for <a href="https://en.cppreference.com/w/cpp/utility/tuple">std::tuple&lt;Ts...&gt;</a></li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md7"></a>
Getting starting</h2>
<p>This library is single-header, header-only. Users may use it in various ways, however <a href="https://cmake.org/">CMake</a> is the promoted one for both download and configuration.</p>
<h3><a class="anchor" id="autotoc_md8"></a>
Integration</h3>
<h4><a class="anchor" id="autotoc_md9"></a>
Plain download</h4>
<ul>
<li><b>Fetch</b> <a href="https://raw.githubusercontent.com/GuillaumeDua/CppShelf/main/includes/ag/csl/ag.hpp">the header file</a> and deal with the build yourself, or ...</li>
<li><b>Clone</b> the repo, or add it as a <a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules">git submodule</a> to your project.</li>
</ul>
<blockquote class="doxtable">
<p>‚ö†Ô∏è Proceeding the ways enumerated above is fast &amp; simple. However this prevent users from using certain configuration mechanismes. <em>See the <a href="#configuration">configuration</a> section for more information</em>. </p>
</blockquote>
<h4><a class="anchor" id="autotoc_md10"></a>
CMake</h4>
<ul>
<li><b>Fetch</b> the header file using <a href="https://cmake.org/cmake/help/latest/module/FetchContent.html">FetchContent</a>, or <a href="https://cmake.org/cmake/help/latest/module/ExternalProject.html">ExternalProject</a>.</li>
</ul>
<p>Then use the <code>csl::ag</code> target.</p>
<blockquote class="doxtable">
<p>Note : to disable tests, set the cmake cache variable <code>CSL_BUILD_ALL_TESTS</code> to false. </p>
</blockquote>
<h3><a class="anchor" id="autotoc_md11"></a>
Configuration</h3>
<h4><a class="anchor" id="autotoc_md12"></a>
Bitfields support</h4>
<p>‚ö†Ô∏è By default, bitfields support is <b>disabled</b>. <br  />
 Using features for this library with any aggregate type using custom layout will results in ‚ò£Ô∏è <b>undefined behavior</b>. <br  />
 Most likely, a compile-time error will be emitted. However, such behavior is not guaranteed.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>S {</div>
<div class="line">    <span class="keywordtype">int</span> b0 : 1, b1 : 1, b2 : 1, b3 : 1;</div>
<div class="line">    char : 0;</div>
<div class="line">    <span class="keywordtype">char</span> &amp;&amp; c;</div>
<div class="line">};</div>
<div class="line">static_assert(csl::ag::size_v&lt;S&gt; == 5); <span class="comment">// ‚ò£Ô∏è UB by default</span></div>
</div><!-- fragment --><p>If you plan to use features of this library with aggregate types containing bitfields, you must first enable such support either using one of the two following ways :</p>
<ul>
<li>Using <code>CMake</code>, edit the cache to set the <code>CSL_AG_ENABLE_BITFIELDS_SUPPORT</code> option to <code>on</code>. <br  />
 or</li>
<li>Using plain <b>C++</b>, define the preprocessor variable <code>CSL_AG_ENABLE_BITFIELDS_SUPPORT</code>. <div class="fragment"><div class="line"><span class="preprocessor">#define CSL_AG_ENABLE_BITFIELDS_SUPPORT true</span></div>
</div><!-- fragment --></li>
</ul>
<blockquote class="doxtable">
<p>‚ùî <b>Question</b> : Why such option exists ?</p>
<p>The (compile-time) algorithm internally used by the library to count fields for aggregate types possibly containing bitfields is much slower than the default one. <br  />
 One might want to challenge his/her project's design in order to avoid such high performance cost. </p>
</blockquote>
<h4><a class="anchor" id="autotoc_md13"></a>
Highier limit for aggregate field count</h4>
<p>This library relies on a <b>CMake</b> cache variable <code>CSL_AG_MAX_FIELDS_COUNT_OPTION</code> to generate code in order to properly handle aggregate types with fields up to this value.</p>
<p>By default, <code>CSL_AG_MAX_FIELDS_COUNT_OPTION</code> is set to <code>128</code>, meaning the library supports aggregate types with up to 128 fields.</p>
<p>To extend such support, edit your <b>CMake</b> cache to set <code>CSL_AG_MAX_FIELDS_COUNT_OPTION</code> to a greater integral value.</p>
<blockquote class="doxtable">
<p>‚ùî <b>Question</b> : What if I don't use <b>CMake</b> ?</p>
<p>Then the library will always use the default value. </p>
</blockquote>
<blockquote class="doxtable">
<p>‚ùî <b>Question</b> : Why such configuration/limitation ?</p>
<p>Despite interesting proposals that aim to enhance &amp; offer new code generation mecanisms as part of the C++ language, such features are not available yet. <br  />
</p>
<p>The choice here to use <b>CMake</b> in order to generate C++ code <b>upstream</b> is a reasonable trade-off to guarantee easier debugging and avoid dark-magic tricks (such as relying on PP macros, etc.).</p>
<p>üëâ If you are willing to propose a better design, you can submit a <a href="https://github.com/GuillaumeDua/CppShelf/pulls">PR here</a>. </p>
</blockquote>
<hr  />
<h2><a class="anchor" id="autotoc_md15"></a>
Content</h2>
<p>All components that are part of the public interface are defined in the namespace <code>csl::ag</code>, <br  />
 except for nested-namespaces named <code>details</code>. <br  />
</p>
<p>In other words, the library provides <b>no guarantee</b> to any direct use of namespaces named with a pattern like <code>csl::ag::*::details::*</code>.</p>
<h3><a class="anchor" id="autotoc_md16"></a>
Aggregate-related concepts</h3>
<p>All concepts that are part of the public interface are defined in the namespace <code>csl::ag::concepts</code>.</p>
<h4><a class="anchor" id="autotoc_md17"></a>
unqualified_aggregate&lt;T&gt;</h4>
<p>Requirements that given <code>T</code> type must meet to be considered as an unqualified (e.g, not cvref-qualified) aggregate type by this library components.</p>
<ul>
<li><code>std::is_aggregate_v&lt;T&gt;</code></li>
<li><code>not std::is_empty_v&lt;T&gt;</code></li>
<li><code>not std::is_union_v&lt;T&gt;</code></li>
<li><code>not std::is_polymorphic_v&lt;T&gt;</code></li>
<li><code>not std::is_reference_v&lt;T&gt;</code></li>
</ul>
<h4><a class="anchor" id="autotoc_md18"></a>
aggregate&lt;T&gt;</h4>
<p><code>T</code> must be a possibly cvref-qualified aggregate, meeting the <code>unqualified_aggregate&lt;std::remove_cvref_t&lt;T&gt;&gt;</code> requirement.</p>
<p>Note that such requirement is widely used in this library.</p>
<h4><a class="anchor" id="autotoc_md19"></a>
aggregate_constructible_from&lt;T, args_ts...&gt;</h4>
<p><code>T</code> must be a valid aggregate type, constructible using brace-initialization using values of types <code>args_ts...</code>.</p>
<h4><a class="anchor" id="autotoc_md20"></a>
aggregate_constructible_from_n_values&lt;T, std::size_t N&gt;</h4>
<p><code>T</code> must be a valid aggregate type, constructible using <code>N</code> values (which types does not matter here). <br  />
 This does not mean that <code>T</code> has <code>N</code> fields : it can be more.</p>
<h4><a class="anchor" id="autotoc_md21"></a>
tuplelike&lt;T&gt;</h4>
<p><code>T</code> must meet the tuplelike interface, with valid implementation of :</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/utility/tuple/tuple_size">std::tuple_size_v</a></li>
<li><a href="https://en.cppreference.com/w/cpp/utility/tuple/get">std::get&lt;std::size_t&gt;(/*possibly cvref-qualified */ T)</a></li>
<li><a href="https://en.cppreference.com/w/cpp/utility/tuple/tuple_element">std::tuple_element&lt;std::size_t, T&gt;</a></li>
</ul>
<h4><a class="anchor" id="autotoc_md22"></a>
csl::ag::concepts::structured_bindable&lt;T&gt;</h4>
<p><code>T</code> must either match <code>tuplelike&lt;T&gt;</code> or <code>aggregate&lt;T&gt;</code> requirements.</p>
<p>See the <a href="https://en.cppreference.com/w/cpp/language/structured_binding">structured_binding documentation</a> for more details.</p>
<h3><a class="anchor" id="autotoc_md23"></a>
Aggregate-related type-traits</h3>
<h4><a class="anchor" id="autotoc_md24"></a>
csl::ag::size&lt;T&gt;</h4>
<p>Integral constant type which value represents the count of fields for a given aggregate type.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>A{ <span class="keywordtype">int</span> i; <span class="keywordtype">float</span> f; };</div>
<div class="line">static_assert(<a class="code" href="structcsl_1_1ag_1_1size.html">csl::ag::size&lt;A&gt;::value</a> == 2);</div>
<div class="line">static_assert(csl::ag::size_v&lt;A&gt;      == 2);</div>
</div><!-- fragment --><p><a href="https://godbolt.org/z/5cr1x7K3T"><img src="https://github.com/GuillaumeDua/CppShelf/blob/main/docs/details/images/compiler-explorer.png?raw=true" alt="" align="left" width="20" height="20" style="Padding: 2px 4px 0px 0px" class="inline"/> Try me on compiler-explorer</a>.</p>
<p>Just like <code>std::tuple_size/std::tuple_size_v</code>, the <b>value</b> can be accessed using a convenience alias :</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;csl::ag::concepts::aggregate T&gt;</div>
<div class="line">constexpr <span class="keyword">auto</span> size_v = size&lt;T&gt;::value;</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md25"></a>
csl::ag::element&lt;std::size_t, concepts::aggregate&gt;</h4>
<p>Type-identity of a field's type of a given aggregate type.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>A{ <span class="keywordtype">int</span> i; <span class="keywordtype">float</span> f; };</div>
<div class="line">static_assert(std::same_as&lt;<span class="keywordtype">int</span>,   csl::ag::element_t&lt;0, A&gt;&gt;);</div>
<div class="line">static_assert(std::same_as&lt;<span class="keywordtype">float</span>, csl::ag::element_t&lt;1, A&gt;&gt;);</div>
</div><!-- fragment --><p><a href="https://godbolt.org/z/xMYzezxoo"><img src="https://github.com/GuillaumeDua/CppShelf/blob/main/docs/details/images/compiler-explorer.png?raw=true" alt="" align="left" width="20" height="20" style="Padding: 2px 4px 0px 0px" class="inline"/> Try me on compiler-explorer</a>.</p>
<p>Just like <code>std::tuple_element/std::tuple_element_t</code>, the <b>type</b> can be accessed using a convenience alias :</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;std::<span class="keywordtype">size_t</span> N, concepts::aggregate T&gt;</div>
<div class="line"><span class="keyword">using</span> element_t = <span class="keyword">typename</span> element&lt;N, T&gt;::type;</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md26"></a>
csl::ag::view_element&lt;std::size_t, concepts::aggregate&gt;</h4>
<p>In a similar way to <code>csl::ag::element&lt;std::size_t, T&gt;</code>, <code>csl::ag::view_element&lt;std::size_t,T&gt;</code> is a type-identity for a field's type of a given aggregate view type. <br  />
 For more details about aggregate's view, see the <a href="#non-owning-conversion-view">to-tuple non-owning conversion (view)</a> section.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>A{ <span class="keywordtype">int</span> i; <span class="keywordtype">float</span> &amp; f; <span class="keyword">const</span> <span class="keywordtype">char</span> &amp;&amp; c; };</div>
<div class="line"> </div>
<div class="line">static_assert(std::same_as&lt;<span class="keywordtype">int</span>&amp;&amp;,        csl::ag::view_element_t&lt;0, A&amp;&amp;&gt;&gt;);</div>
<div class="line">static_assert(std::same_as&lt;<span class="keywordtype">float</span>&amp;,       csl::ag::view_element_t&lt;1, A&amp;&amp;&gt;&gt;);</div>
<div class="line">static_assert(std::same_as&lt;<span class="keyword">const</span> <span class="keywordtype">char</span>&amp;&amp;, csl::ag::view_element_t&lt;2, A&amp;&amp;&gt;&gt;);</div>
<div class="line"> </div>
<div class="line">static_assert(std::same_as&lt;<span class="keyword">const</span> <span class="keywordtype">int</span>&amp;,    csl::ag::view_element_t&lt;0, const A&amp;&gt;&gt;);</div>
<div class="line">static_assert(std::same_as&lt;<span class="keywordtype">float</span>&amp;,        csl::ag::view_element_t&lt;1, const A&amp;&gt;&gt;);</div>
<div class="line">static_assert(std::same_as&lt;<span class="keyword">const</span> <span class="keywordtype">char</span>&amp;&amp;,  csl::ag::view_element_t&lt;2, const A&amp;&gt;&gt;);</div>
</div><!-- fragment --><p><a href="https://godbolt.org/z/xMYzezxoo"><img src="https://github.com/GuillaumeDua/CppShelf/blob/main/docs/details/images/compiler-explorer.png?raw=true" alt="" align="left" width="20" height="20" style="Padding: 2px 4px 0px 0px" class="inline"/> Try me on compiler-explorer</a>.</p>
<p>The <code>type</code> nested-type can be accessed using a convenience alias :</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;std::<span class="keywordtype">size_t</span> N, concepts::aggregate T&gt;</div>
<div class="line"><span class="keyword">using</span> view_element_t = <span class="keyword">typename</span> view_element&lt;N, T&gt;::type;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md27"></a>
to-tuple conversion for aggregate types</h3>
<p>This library provides two ways to convert an aggregate's value to <a href="https://en.cppreference.com/w/cpp/utility/tuple">std::tuple</a>, distinguishing between proprietary and non-proprietary tuples of values.</p>
<ul>
<li><p class="startli"><b>Owning</b> is a plain translation of an aggregate type as a tuple.</p>
<p class="startli">Each <code>std::tuple_element_t</code> of the resulting type will be strictly equivalent to <code>csl::ag::element_t</code> of the source one. <br  />
 The value of each field is pass by-value (understand: copy).</p>
<p class="startli">See the <a href="#owning-conversion">Owning conversion</a> section hereunder.</p>
</li>
<li><p class="startli"><b>Non-owning</b> (undestand: <b>view</b>, or <b>lightweight accessor</b>) conversion offers a cheap way to convert an aggregate into a tuple of references; <br  />
 offering a convenient way to then use already-existing features - <em>or even libraries</em> - that operates on <a href="https://en.cppreference.com/w/cpp/utility/tuple">std::tuple</a> values.</p><ul>
<li>Field types that already are references will remain unchanged : <code>csl::ag::element_t</code> is strictly equivalent to <code>std::tuple_element_t</code>.</li>
<li>Field types that are not references will acquire the cvref-qualifier of the source aggregate value.</li>
</ul>
<p class="startli">See the <a href="#non-owning-conversion-view">Non-owning conversion (view)</a> section hereunder.</p>
</li>
</ul>
<h4><a class="anchor" id="autotoc_md28"></a>
Owning conversion</h4>
<p>The following factory (as a function) creates a <code>std::tuple</code> of <code>csl::ag::elements</code>, never altered. <br  />
</p>
<p>The value of each member-variable of the aggregate's value are <a href="https://en.cppreference.com/w/cpp/utility/forward">forward</a>ed, in order to preserve cvref-semantic. <br  />
 Meaning that using a <code>const-lvalue-reference</code> of a given type <code>S</code> 's value will result in a copy of each of its field that are not ref-qualified, <br  />
 while using a <code>rvalue-reference</code> will results in a perfect-forwarding that member-variable.</p>
<table class="doxtable">
<tr>
<th>C++ code ( <a href="https://godbolt.org/z/Yqh1q3Wea">Try me on compiler-explorer <img src="https://github.com/GuillaumeDua/CppShelf/blob/main/docs/details/images/compiler-explorer.png?raw=true" alt="" align="left" width="20" height="20" style="Padding: 2px 4px 0px 0px" class="inline"/> </a> ) </th><th>Console output  </th></tr>
<tr>
<td><p class="starttd"></p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>A{ <span class="keywordtype">int</span> i; <span class="keywordtype">float</span> f; };</div>
<div class="line"> </div>
<div class="line">constexpr <span class="keyword">auto</span> value = A{ .i = 42, .f = 0.13f };</div>
<div class="line">constexpr <span class="keyword">auto</span> value_as_tuple = csl::ag::as_tuple(std::move(value));</div>
<div class="line"> </div>
<div class="line">[&amp;]&lt;std::size_t ... indexes&gt;(std::index_sequence&lt;indexes...&gt;){</div>
<div class="line">    static_assert((std::same_as&lt;</div>
<div class="line">        csl::ag::element_t&lt;indexes, A&gt;, <span class="comment">// { 0: int, 1:float }</span></div>
<div class="line">        std::tuple_element_t&lt;indexes, std::remove_cvref_t&lt;decltype(value_as_tuple)&gt;&gt;</div>
<div class="line">    &gt; and ...));</div>
<div class="line"> </div>
<div class="line">    ((std::cout &lt;&lt; std::get&lt;indexes&gt;(value_as_tuple) &lt;&lt; <span class="charliteral">&#39; &#39;</span>), ...);</div>
<div class="line">}(std::make_index_sequence&lt;csl::ag::size_v&lt;A&gt;&gt;{});</div>
</div><!-- fragment --><p class="endtd"></p>
</td><td><p class="starttd"></p>
<div class="fragment"><div class="line">42 0.13</div>
</div><!-- fragment --><p class="endtd"></p>
</td></tr>
</table>
<p>The main advantage here is to use such function in a <code>constexpr</code> contexts. <br  />
 A precondition while doing so is that each aggregates field's value must be usable in a constexpr context though (e.g <b>not</b> ref-qualified).</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>A{ <span class="keywordtype">int</span> i; <span class="keywordtype">float</span> f; };</div>
<div class="line"> </div>
<div class="line">static_assert(std::same_as&lt;</div>
<div class="line">    std::tuple&lt;int, float&gt;,</div>
<div class="line">    csl::ag::to_tuple_t&lt;A&gt;</div>
<div class="line">&gt;);</div>
<div class="line"> </div>
<div class="line">static_assert(std::same_as&lt;<span class="keywordtype">int</span>, csl::ag::element_t&lt;0, A&gt;&gt;);</div>
<div class="line">static_assert(std::same_as&lt;<span class="keywordtype">int</span>, std::tuple_element_t&lt;0, csl::ag::to_tuple_t&lt;A&gt;&gt;&gt;);</div>
<div class="line">static_assert(std::same_as&lt;<span class="keywordtype">int</span>, std::tuple_element_t&lt;0,decltype(csl::ag::as_tuple(A{}))&gt;&gt;);</div>
<div class="line"> </div>
<div class="line">constexpr <span class="keyword">auto</span> value = A{ .i = 42, .f = 0.13f };</div>
<div class="line">constexpr <span class="keyword">auto</span> value_as_tuple = csl::ag::as_tuple(std::move(value));</div>
<div class="line"> </div>
<div class="line">static_assert(42    == std::get&lt;0&gt;(value_as_tuple));</div>
<div class="line">static_assert(0.13f == std::get&lt;1&gt;(value_as_tuple));</div>
</div><!-- fragment --><p><a href="https://godbolt.org/z/EE7494zbv"><img src="https://github.com/GuillaumeDua/CppShelf/blob/main/docs/details/images/compiler-explorer.png?raw=true" alt="" align="left" width="20" height="20" style="Padding: 2px 4px 0px 0px" class="inline"/> Try me on compiler-explorer</a>.</p>
<p>Additionaly, <a href="https://en.cppreference.com/w/cpp/utility/tuple/tuple_element">std::tuple_element_t</a> can be use to obtains the conversion result's element types.</p>
<ul>
<li><p class="startli">Example 1 : aggregate type with not-cvref-qualified fields</p>
<table class="doxtable">
<tr>
<th>C++ code ( <a href="https://godbolt.org/z/17Es3oooY">Try me on compiler-explorer <img src="https://github.com/GuillaumeDua/CppShelf/blob/main/docs/details/images/compiler-explorer.png?raw=true" alt="" align="left" width="20" height="20" style="Padding: 2px 4px 0px 0px" class="inline"/> </a> ) </th><th>Console output  </th></tr>
<tr>
<td><p class="starttd"></p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>A{ <span class="keywordtype">int</span> i; <span class="keywordtype">float</span> f; };</div>
<div class="line">constexpr <span class="keyword">auto</span> value = csl::ag::as_tuple(A{ .i = 42, .f = 0.13f });</div>
<div class="line"> </div>
<div class="line">[&amp;value]&lt;std::size_t ... indexes&gt;(std::index_sequence&lt;indexes...&gt;){</div>
<div class="line">    ((std::cout &lt;&lt; std::get&lt;indexes&gt;(value) &lt;&lt; <span class="charliteral">&#39; &#39;</span>), ...);</div>
<div class="line">}(std::make_index_sequence&lt;csl::ag::size_v&lt;A&gt;&gt;{});</div>
<div class="line"> </div>
<div class="line">static_assert(std::same_as&lt;</div>
<div class="line">    <span class="keywordtype">int</span>,</div>
<div class="line">    std::tuple_element_t&lt;0, std::remove_cvref_t&lt;decltype(value)&gt;&gt;</div>
<div class="line">&gt;);                      <span class="comment">// \-&gt; same as csl::ag::to_tuple_t&lt;A&gt;</span></div>
<div class="line">static_assert(std::same_as&lt;</div>
<div class="line">    <span class="keywordtype">float</span>,</div>
<div class="line">    std::tuple_element_t&lt;1, std::remove_cvref_t&lt;decltype(value)&gt;&gt;</div>
<div class="line">&gt;);</div>
</div><!-- fragment --><p class="endtd"></p>
</td><td><p class="starttd"></p>
<div class="fragment"><div class="line">42 0.13 </div>
</div><!-- fragment --><p class="endtd"></p>
</td></tr>
</table>
</li>
<li><p class="startli">Example 2 : aggregate type with ref-qualified fields</p>
<table class="doxtable">
<tr>
<th>C++ code ( <a href="https://godbolt.org/z/17Es3oooY">Try me on compiler-explorer <img src="https://github.com/GuillaumeDua/CppShelf/blob/main/docs/details/images/compiler-explorer.png?raw=true" alt="" align="left" width="20" height="20" style="Padding: 2px 4px 0px 0px" class="inline"/> </a> ) </th><th>Console output  </th></tr>
<tr>
<td><p class="starttd"></p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>A{ <span class="keywordtype">int</span> &amp; i; <span class="keywordtype">float</span> &amp;&amp; f; };</div>
<div class="line"><span class="keywordtype">int</span> i = 42; <span class="keywordtype">float</span> f = .13f;</div>
<div class="line"><span class="comment">/* not constexpr */</span> <span class="keyword">auto</span> value = csl::ag::as_tuple(A{ .i = i, .f = std::move(f) });</div>
<div class="line"> </div>
<div class="line">[&amp;value]&lt;std::size_t ... indexes&gt;(std::index_sequence&lt;indexes...&gt;){</div>
<div class="line">    ((std::cout &lt;&lt; std::get&lt;indexes&gt;(value) &lt;&lt; <span class="charliteral">&#39; &#39;</span>), ...);</div>
<div class="line">}(std::make_index_sequence&lt;csl::ag::size_v&lt;A&gt;&gt;{});</div>
<div class="line"> </div>
<div class="line">static_assert(std::same_as&lt;</div>
<div class="line">    <span class="keywordtype">int</span>&amp;,</div>
<div class="line">    std::tuple_element_t&lt;0, std::remove_cvref_t&lt;decltype(value)&gt;&gt;</div>
<div class="line">&gt;);</div>
<div class="line">static_assert(std::same_as&lt;</div>
<div class="line">    <span class="keywordtype">float</span>&amp;&amp;,</div>
<div class="line">    std::tuple_element_t&lt;1, std::remove_cvref_t&lt;decltype(value)&gt;&gt;</div>
<div class="line">&gt;);</div>
</div><!-- fragment --><p class="endtd"></p>
</td><td><p class="starttd"></p>
<div class="fragment"><div class="line">42 0.13 </div>
</div><!-- fragment --><p class="endtd"></p>
</td></tr>
</table>
</li>
</ul>
<h4><a class="anchor" id="autotoc_md29"></a>
Non-owning conversion (view, lightweight accessor)</h4>
<p>This factory (as a function) creates non-owning <b>lightweight accessors</b> (views), <br  />
 returning a non-owning tuple (<code>std::tuple</code> of references), for which each element represents an accessor to an aggregate value's field.</p>
<p>Note that in order to preserve <code>cvref semantic</code>, the possibly-used <code>cvref qualifiers</code> of the aggregate's value are propagated to qualify each of non-ref-qualified elements of the result tuple-type. <br  />
 Ref-qualified fields type remain unchanged.</p>
<p>The conversion's result type can be access using the <code>tuple_view(_t)&lt;T&gt;</code> type-trait.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>type { <span class="keywordtype">int</span> lvalue; <span class="keywordtype">int</span> &amp; llvalue; <span class="keyword">const</span> <span class="keywordtype">int</span> &amp; const_lvalue; <span class="keywordtype">int</span> &amp;&amp; rvalue; };</div>
<div class="line"><span class="keywordtype">int</span> i = 42;</div>
<div class="line"> </div>
<div class="line">{ <span class="comment">// using a rvalue</span></div>
<div class="line">    [[maybe_unused]] <span class="keyword">auto</span> view = csl::ag::as_tuple_view(type{ i, i, i, std::move(i) });</div>
<div class="line"> </div>
<div class="line">    static_assert(std::same_as&lt;</div>
<div class="line">        decltype(view),</div>
<div class="line">        csl::ag::tuple_view_t&lt;type&amp;&amp;&gt;</div>
<div class="line">    &gt;);</div>
<div class="line">    static_assert(std::same_as&lt;</div>
<div class="line">        decltype(view),</div>
<div class="line">        std::tuple&lt;int&amp;&amp;, int&amp;, const int&amp;, int&amp;&amp;&gt;</div>
<div class="line">        <span class="comment">//         ^^^^^ cvref-qualified (rvalue-ref) propagation</span></div>
<div class="line">    &gt;);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">{ <span class="comment">// using a const-lvalue</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> &amp; value = type{ i, i, i, std::move(i) };</div>
<div class="line">    [[maybe_unused]] <span class="keyword">auto</span> view = csl::ag::as_tuple_view(value);</div>
<div class="line"> </div>
<div class="line">    static_assert(std::same_as&lt;</div>
<div class="line">        decltype(view),</div>
<div class="line">        csl::ag::tuple_view_t&lt;const type&amp;&gt;</div>
<div class="line">    &gt;);</div>
<div class="line">    static_assert(std::same_as&lt;</div>
<div class="line">        decltype(view),</div>
<div class="line">        std::tuple&lt;const int &amp;, int&amp;, const int &amp;, int&amp;&amp;&gt;</div>
<div class="line">        <span class="comment">//         ^^^^^^^^^^^ cvref-qualified (const-lvalue-ref) propagation</span></div>
<div class="line">    &gt;);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a href="https://godbolt.org/z/39bTrKzzo"><img src="https://github.com/GuillaumeDua/CppShelf/blob/main/docs/details/images/compiler-explorer.png?raw=true" alt="" align="left" width="20" height="20" style="Padding: 2px 4px 0px 0px" class="inline"/> Try me on compiler-explorer</a>.</p>
<p>Additionally, <code>csl::ag::view_element(_t)&lt;N,T&gt;</code> can be used to obtains a field's type information, by index.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>type { <span class="keywordtype">int</span> lvalue; <span class="keywordtype">int</span> &amp; llvalue; <span class="keyword">const</span> <span class="keywordtype">int</span> &amp; const_lvalue; <span class="keywordtype">int</span> &amp;&amp; rvalue; };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// field 0 IS NOT a reference : cvref-qualifiers propagation</span></div>
<div class="line">static_assert(std::same_as&lt;<span class="keywordtype">int</span> &amp;&amp;,</div>
<div class="line">    csl::ag::view_element_t&lt;0, type&amp;&amp;&gt;</div>
<div class="line">&gt;);</div>
<div class="line">static_assert(std::same_as&lt;<span class="keywordtype">int</span> &amp;,</div>
<div class="line">    csl::ag::view_element_t&lt;0, type&amp;&gt;</div>
<div class="line">&gt;);</div>
<div class="line">static_assert(std::same_as&lt;<span class="keyword">const</span> <span class="keywordtype">int</span> &amp;&amp;,</div>
<div class="line">    csl::ag::view_element_t&lt;0, const type&amp;&amp;&gt;</div>
<div class="line">&gt;);</div>
<div class="line">static_assert(std::same_as&lt;<span class="keyword">const</span> <span class="keywordtype">int</span> &amp;,</div>
<div class="line">    csl::ag::view_element_t&lt;0, const type&amp;&gt;</div>
<div class="line">&gt;);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// field 0 IS a reference : no cvref-qualifiers propagation</span></div>
<div class="line">static_assert(std::same_as&lt;<span class="keywordtype">int</span> &amp;,</div>
<div class="line">    csl::ag::view_element_t&lt;1, type&amp;&amp;&gt;</div>
<div class="line">&gt;);</div>
<div class="line">static_assert(std::same_as&lt;<span class="keywordtype">int</span> &amp;,</div>
<div class="line">    csl::ag::view_element_t&lt;1, type&amp;&gt;</div>
<div class="line">&gt;);</div>
<div class="line">static_assert(std::same_as&lt;<span class="keywordtype">int</span> &amp;,</div>
<div class="line">    csl::ag::view_element_t&lt;1, const type&amp;&amp;&gt;</div>
<div class="line">&gt;);</div>
<div class="line">static_assert(std::same_as&lt;<span class="keywordtype">int</span> &amp;,</div>
<div class="line">    csl::ag::view_element_t&lt;1, const type&amp;&gt;</div>
<div class="line">&gt;);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// still not propagation for fields 2 and 3 ...</span></div>
</div><!-- fragment --><p><a href="https://godbolt.org/z/M3ejaf7Mc"><img src="https://github.com/GuillaumeDua/CppShelf/blob/main/docs/details/images/compiler-explorer.png?raw=true" alt="" align="left" width="20" height="20" style="Padding: 2px 4px 0px 0px" class="inline"/> Try me on compiler-explorer</a>.</p>
<h3><a class="anchor" id="autotoc_md30"></a>
tuplelike interface for aggregates</h3>
<h4><a class="anchor" id="autotoc_md31"></a>
std::tuple_element</h4>
<div class="fragment"><div class="line"><span class="keyword">struct </span>type{ <span class="keyword">const</span> <span class="keywordtype">int</span> i = 0; <span class="keywordtype">char</span> &amp; c; };</div>
<div class="line"><span class="keywordtype">char</span> c = <span class="charliteral">&#39;c&#39;</span>;</div>
<div class="line"><span class="keyword">auto</span> value = type{ 42, c }; <span class="comment">// NOLINT</span></div>
<div class="line"> </div>
<div class="line">static_assert(std::same_as&lt;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>,</div>
<div class="line">    std::tuple_element_t&lt;0, std::remove_cvref_t&lt;decltype(value)&gt;&gt;</div>
<div class="line">&gt;);</div>
<div class="line">static_assert(std::same_as&lt;</div>
<div class="line">    <span class="keywordtype">char</span>&amp;,</div>
<div class="line">    std::tuple_element_t&lt;1, std::remove_cvref_t&lt;decltype(value)&gt;&gt;</div>
<div class="line">&gt;);</div>
</div><!-- fragment --><p><a href="https://godbolt.org/z/YPj7931b9"><img src="https://github.com/GuillaumeDua/CppShelf/blob/main/docs/details/images/compiler-explorer.png?raw=true" alt="" align="left" width="20" height="20" style="Padding: 2px 4px 0px 0px" class="inline"/> Try me on compiler-explorer</a>.</p>
<h4><a class="anchor" id="autotoc_md32"></a>
std::get</h4>
<p>Simple example :</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>A{ <span class="keywordtype">int</span> i; <span class="keywordtype">float</span> f; };</div>
<div class="line"><span class="keyword">auto</span> value = A { .i = 42, .f = 0.13f };</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; std::get&lt;0&gt;(value) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; std::get&lt;1&gt;(value) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line"> </div>
<div class="line">static_assert(std::same_as&lt;</div>
<div class="line">    <span class="keywordtype">int</span> &amp;,</div>
<div class="line">    decltype(std::get&lt;0&gt;(value))</div>
<div class="line">&gt;);</div>
<div class="line">static_assert(std::same_as&lt;</div>
<div class="line">    <span class="keywordtype">float</span> &amp;,</div>
<div class="line">    decltype(std::get&lt;1&gt;(value))</div>
<div class="line">&gt;);</div>
</div><!-- fragment --><div class="fragment"><div class="line">42, 0.13</div>
</div><!-- fragment --><p><a href="https://godbolt.org/z/je4Gr16h5"><img src="https://github.com/GuillaumeDua/CppShelf/blob/main/docs/details/images/compiler-explorer.png?raw=true" alt="" align="left" width="20" height="20" style="Padding: 2px 4px 0px 0px" class="inline"/> Try me on compiler-explorer</a>.</p>
<p>Slightly more advanced example :</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>A{ <span class="keywordtype">int</span> i; <span class="keywordtype">float</span> f; };</div>
<div class="line"><span class="keyword">auto</span> value = A{ .i = 42, .f = 0.13f };</div>
<div class="line"> </div>
<div class="line">[&amp;value]&lt;std::size_t ... indexes&gt;(std::index_sequence&lt;indexes...&gt;){</div>
<div class="line">    ((std::cout &lt;&lt; std::get&lt;indexes&gt;(value) &lt;&lt; <span class="charliteral">&#39; &#39;</span>), ...);</div>
<div class="line">}(std::make_index_sequence&lt;csl::ag::size_v&lt;A&gt;&gt;{});</div>
</div><!-- fragment --><div class="fragment"><div class="line">42 0.13 </div>
</div><!-- fragment --><p><a href="https://godbolt.org/z/j9bhr4WrP"><img src="https://github.com/GuillaumeDua/CppShelf/blob/main/docs/details/images/compiler-explorer.png?raw=true" alt="" align="left" width="20" height="20" style="Padding: 2px 4px 0px 0px" class="inline"/> Try me on compiler-explorer</a>.</p>
<p>Note that <code>constexpr</code>-ness is preserved :</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>A{ <span class="keywordtype">int</span> i; <span class="keywordtype">char</span> c; };</div>
<div class="line">constexpr <span class="keyword">auto</span> value = A{ 42, <span class="charliteral">&#39;c&#39;</span> };</div>
<div class="line">static_assert(csl::ag::get&lt;0&gt;(value) == 42);    <span class="comment">// pass</span></div>
<div class="line">static_assert(csl::ag::get&lt;1&gt;(value) == <span class="charliteral">&#39;c&#39;</span>);   <span class="comment">// pass</span></div>
</div><!-- fragment --><p><a href="https://godbolt.org/z/h9jbrc8d6"><img src="https://github.com/GuillaumeDua/CppShelf/blob/main/docs/details/images/compiler-explorer.png?raw=true" alt="" align="left" width="20" height="20" style="Padding: 2px 4px 0px 0px" class="inline"/> Try me on compiler-explorer</a>.</p>
<h3><a class="anchor" id="autotoc_md33"></a>
Pretty-printing</h3>
<p>There are two way to pretty-print aggregate types :</p>
<ul>
<li>using the legacy C++'s way : <code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, T&amp;&amp;)</code> overload</li>
<li>using the <code>fmt</code> or <code>std::format</code> library</li>
</ul>
<h4><a class="anchor" id="autotoc_md34"></a>
using std::ostream :</h4>
<p>Simple example :</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;csl/ag.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">using namespace </span>csl::ag::io;</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">struct </span>A{ <span class="keywordtype">int</span> i; <span class="keywordtype">float</span> f; };</div>
<div class="line">  std::cout &lt;&lt; A{ .i = 42, .f = .13f };</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line">A &amp;&amp; : {</div>
<div class="line">   [0] int : 42</div>
<div class="line">   [1] float : 0.13</div>
<div class="line">}</div>
</div><!-- fragment --><p><a href="https://godbolt.org/z/q8Yeq4e83"><img src="https://github.com/GuillaumeDua/CppShelf/blob/main/docs/details/images/compiler-explorer.png?raw=true" alt="" align="left" width="20" height="20" style="Padding: 2px 4px 0px 0px" class="inline"/> Try me on compiler-explorer</a>.</p>
<p>Advanced example :</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;tuple&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;array&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>A{ <span class="keywordtype">int</span> i; <span class="keywordtype">float</span> f; };</div>
<div class="line"><span class="keyword">struct </span>B{};</div>
<div class="line"><span class="keyword">auto</span> &amp; operator&lt;&lt;(std::ostream &amp; os, B) { </div>
<div class="line">  <span class="keywordflow">return</span> os &lt;&lt; <span class="stringliteral">&quot;user-defined operator&lt;&lt;(std::ostream&amp;, const B &amp;)&quot;</span>;</div>
<div class="line">}</div>
<div class="line"><span class="keyword">struct </span>C {</div>
<div class="line">    A a;</div>
<div class="line">    B b;</div>
<div class="line">    <span class="keywordtype">int</span> &amp; i;</div>
<div class="line">    <span class="keyword">const</span> std::string str;</div>
<div class="line">    <span class="keywordtype">char</span> &amp;&amp; c;</div>
<div class="line">    std::tuple&lt;bool, int&gt; t{ <span class="keyword">true</span>, 2 };</div>
<div class="line">    std::array&lt;char, 3&gt; arr{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, <span class="charliteral">&#39;c&#39;</span> };</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;csl/ag.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">  <span class="keyword">using namespace </span>csl::ag::io;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> i = 42;</div>
<div class="line">  <span class="keywordtype">char</span> c = <span class="charliteral">&#39;c&#39;</span>;</div>
<div class="line">  <span class="keyword">auto</span> value = C { </div>
<div class="line">    .a = A{ 13, .12f },</div>
<div class="line">    .b = B{},</div>
<div class="line">    .i = i, .str = <span class="stringliteral">&quot;str&quot;</span>, .c = std::move(c)</div>
<div class="line">  };</div>
<div class="line">  std::cout &lt;&lt; value;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Output :</p>
<div class="fragment"><div class="line">C &amp; : {</div>
<div class="line">   [0] A &amp; : {</div>
<div class="line">      [0] int : 13</div>
<div class="line">      [1] float : 0.12</div>
<div class="line">   }</div>
<div class="line">   [1] B &amp; : user-defined operator&lt;&lt;(std::ostream&amp;, const B &amp;)</div>
<div class="line">   [2] int &amp; : 42</div>
<div class="line">   [3] const std::basic_string&lt;char&gt; : str</div>
<div class="line">   [4] char &amp;&amp; : c</div>
<div class="line">   [5] std::tuple&lt;bool, int&gt; &amp; : {</div>
<div class="line">      [0] bool : 1</div>
<div class="line">      [1] int : 2</div>
<div class="line">   }</div>
<div class="line">   [6] std::array&lt;char, 3&gt; &amp; : {</div>
<div class="line">      [0] char : a</div>
<div class="line">      [1] char : b</div>
<div class="line">      [2] char : c</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><p><a href="https://godbolt.org/z/hsofqExoT"><img src="https://github.com/GuillaumeDua/CppShelf/blob/main/docs/details/images/compiler-explorer.png?raw=true" alt="" align="left" width="20" height="20" style="Padding: 2px 4px 0px 0px" class="inline"/> Try me on compiler-explorer</a>.</p>
<h2><a class="anchor" id="autotoc_md35"></a>
std::tuple and aggregate types homogeneity</h2>
<p>As is, it is quite easy to handle aggregates and tuple in an homogeneous way, despite limitation listed in the next section below.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> do_stuff_with_either_a_tuple_or_aggregate(csl::ag::concepts::structured_bindable <span class="keyword">auto</span> &amp;&amp; value) {</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using</span> value_type = std::remove_cvref_t&lt;decltype(value)&gt;;</div>
<div class="line"> </div>
<div class="line">    constexpr <span class="keyword">auto</span> size = []() constexpr { <span class="comment">// work-around for ADL issue</span></div>
<div class="line">        <span class="keywordflow">if</span> constexpr (csl::ag::concepts::tuplelike&lt;value_type&gt;)</div>
<div class="line">            <span class="keywordflow">return</span> std::tuple_size_v&lt;value_type&gt;;</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> constexpr (csl::ag::concepts::aggregate&lt;value_type&gt;)</div>
<div class="line">            <span class="keywordflow">return</span> csl::ag::size_v&lt;value_type&gt;;</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">            static_assert(<span class="keyword">sizeof</span>(value_type) and <span class="keyword">false</span>, <span class="stringliteral">&quot;Unexpected type&quot;</span>); <span class="comment">// NOLINT</span></div>
<div class="line">    }();</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> do_stuffs = [&amp;]&lt;<span class="keywordtype">size_t</span> index&gt;(){</div>
<div class="line">    <span class="keyword">auto</span> &amp;&amp; element_value = std::get&lt;index&gt;(std::forward&lt;decltype(value)&gt;(value));</div>
<div class="line">    <span class="keyword">using</span> element_value_type = decltype(element_value);</div>
<div class="line">    <span class="keyword">using</span> element_type = std::tuple_element_t&lt;index, value_type&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// do stuffs with element_value, element_type ...</span></div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  [&amp;]&lt;std::size_t ... indexes&gt;(std::index_sequence&lt;indexes...&gt;){</div>
<div class="line">      ((do_stuffs.template operator()&lt;indexes&gt;()), ...);  </div>
<div class="line">  }(std::make_index_sequence&lt;size&gt;{});</div>
<div class="line">}</div>
</div><!-- fragment --><p><a href="https://godbolt.org/z/j6ahehMn1"><img src="https://github.com/GuillaumeDua/CppShelf/blob/main/docs/details/images/compiler-explorer.png?raw=true" alt="" align="left" width="20" height="20" style="Padding: 2px 4px 0px 0px" class="inline"/> Try me on compiler-explorer</a>.</p>
<h2><a class="anchor" id="autotoc_md36"></a>
Current limitations</h2>
<p>As-is, this implementation internally relies on structured-binding, which design choice expose two main limitations :</p>
<ul>
<li>Compile-time evaluation is limited.</li>
<li>By-default behaviors injections, using STL extension/customization point (e.g injecting in the <code>std</code> namespace definitions for <code>get</code>/<code>tuple_element</code>/<code>tuple_size(_v)</code> won't work).</li>
<li>Aggregate types with more fields than their size are currently not supported.</li>
<li>Ill-formed aggregate types using union-fields are not supported</li>
</ul>
<h2><a class="anchor" id="autotoc_md37"></a>
(Internal details) Where's the magic ?</h2>
<p>Everything has its own dirty secrets, and this library is no exception. <br  />
</p>
<p>Internally, and for each given aggregate type, it recursively check if a value of the later is constructible from an aggregate-initialization using <code>N</code> implicitly-castable-to-anything parameters values. <br  />
</p>
<blockquote class="doxtable">
<p>The initial <code>N</code> value is <code>sizeof(T)</code>. </p>
</blockquote>
<p>If the result is a failure, then another attempt using <code>N-1</code> is done, up to 1 (included).</p>
<p>See <code>csl::ag::concepts::aggregate_with_n_fields&lt;T, size&gt;</code></p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> main() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">    <span class="keyword">struct </span>A{ <span class="keywordtype">char</span> a, b, c, d, e, f, g, h; };</div>
<div class="line">    static_assert(<span class="keyword">sizeof</span>(A) == 8);</div>
<div class="line">    static_assert(csl::ag::size_v&lt;A&gt; == 8);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">struct </span>B{ <span class="keywordtype">int</span> a, b; };</div>
<div class="line">    static_assert(<span class="keyword">sizeof</span>(B) == 8);</div>
<div class="line">    static_assert(csl::ag::size_v&lt;B&gt; == 2);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">struct </span><span class="keyword">alignas</span>(32) C { <span class="keywordtype">char</span> c; };</div>
<div class="line">    static_assert(<span class="keyword">sizeof</span>(C) == 32);</div>
<div class="line">    static_assert(csl::ag::size_v&lt;C&gt; == 1);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a href="https://godbolt.org/z/v91bqTEWP"><img src="https://github.com/GuillaumeDua/CppShelf/blob/main/docs/details/images/compiler-explorer.png?raw=true" alt="" align="left" width="20" height="20" style="Padding: 2px 4px 0px 0px" class="inline"/> Try me on compiler-explorer</a>. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="astructcsl_1_1ag_1_1size_html"><div class="ttname"><a href="structcsl_1_1ag_1_1size.html">csl::ag::size</a></div><div class="ttdef"><b>Definition:</b> ag.hpp:1915</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
